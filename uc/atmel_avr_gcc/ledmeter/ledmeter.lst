   1               		.file	"ledmeter.c"
   2               		.arch atmega8535
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  74               	.global	running_chronometer
  75               	.global	running_chronometer
  76               		.section .bss
  79               	running_chronometer:
  80 0000 0000      		.skip 2,0
  81               		.text
  84               	.global	init_time
  86               	init_time:
   1:ledmeter.c    **** // ***********************************************************
   2:ledmeter.c    **** // Project: OpenChrono
   3:ledmeter.c    **** // Author: Sebastien CELLES
   4:ledmeter.c    **** // Module description: an handhelds device for karts, bike or sport cars
   5:ledmeter.c    **** // ***********************************************************
   6:ledmeter.c    **** 
   7:ledmeter.c    **** #include <avr/io.h>              // Most basic include files
   8:ledmeter.c    **** 
   9:ledmeter.c    **** #include <math.h>
  10:ledmeter.c    **** 
  11:ledmeter.c    **** #define F_CPU 1000000UL  // 1 MHz
  12:ledmeter.c    **** #include <avr/delay.h>
  13:ledmeter.c    **** 
  14:ledmeter.c    **** //#include <avr/io.h>              // Most basic include files
  15:ledmeter.c    **** #include <avr/interrupt.h>       // Add the necessary ones
  16:ledmeter.c    **** //#include <avr/signal.h>          // here
  17:ledmeter.c    **** 
  18:ledmeter.c    **** 
  19:ledmeter.c    **** volatile unsigned char a2dCompleteFlag;
  20:ledmeter.c    **** 
  21:ledmeter.c    **** int channel;
  22:ledmeter.c    **** unsigned short analog_result;
  23:ledmeter.c    **** int analog_busy;
  24:ledmeter.c    **** 
  25:ledmeter.c    **** #define Nleds 8  // number of leds connected to the uC
  26:ledmeter.c    **** 
  27:ledmeter.c    **** #define N 50 // number between 0 and 255
  28:ledmeter.c    **** #define Nmax 0xFF
  29:ledmeter.c    **** 
  30:ledmeter.c    **** 
  31:ledmeter.c    **** typedef struct {
  32:ledmeter.c    ****     int hh; //8bits 0-255
  33:ledmeter.c    ****     int mm; //8bits 0-255
  34:ledmeter.c    ****     int ss; //8bits 0-255
  35:ledmeter.c    ****     unsigned short int xx;  //16bits 0-65535
  36:ledmeter.c    **** } time_t;
  37:ledmeter.c    **** 
  38:ledmeter.c    **** time_t current_time;
  39:ledmeter.c    **** time_t last_time;
  40:ledmeter.c    **** time_t best_time;
  41:ledmeter.c    **** 
  42:ledmeter.c    **** int running_chronometer = 0; // 0 false ; -1 true
  43:ledmeter.c    **** 
  44:ledmeter.c    **** void init_time(time_t time) {
  88               	.LM1:
  89               	/* prologue: frame size=8 */
  90 0000 CF93      		push r28
  91 0002 DF93      		push r29
  92 0004 CDB7      		in r28,__SP_L__
  93 0006 DEB7      		in r29,__SP_H__
  94 0008 2897      		sbiw r28,8
  95 000a 0FB6      		in __tmp_reg__,__SREG__
  96 000c F894      		cli
  97 000e DEBF      		out __SP_H__,r29
  98 0010 0FBE      		out __SREG__,__tmp_reg__
  99 0012 CDBF      		out __SP_L__,r28
 100               	/* prologue end (size=10) */
 101 0014 2983      		std Y+1,r18
 102 0016 3A83      		std Y+2,r19
 103 0018 4B83      		std Y+3,r20
 104 001a 5C83      		std Y+4,r21
 105 001c 6D83      		std Y+5,r22
 106 001e 7E83      		std Y+6,r23
 107 0020 8F83      		std Y+7,r24
 108 0022 9887      		std Y+8,r25
  45:ledmeter.c    ****     time.hh = 0;
 110               	.LM2:
 111 0024 1A82      		std Y+2,__zero_reg__
 112 0026 1982      		std Y+1,__zero_reg__
  46:ledmeter.c    ****     time.mm = 0;
 114               	.LM3:
 115 0028 1C82      		std Y+4,__zero_reg__
 116 002a 1B82      		std Y+3,__zero_reg__
  47:ledmeter.c    ****     time.ss = 0;
 118               	.LM4:
 119 002c 1E82      		std Y+6,__zero_reg__
 120 002e 1D82      		std Y+5,__zero_reg__
  48:ledmeter.c    ****     time.xx = 0;
 122               	.LM5:
 123 0030 1886      		std Y+8,__zero_reg__
 124 0032 1F82      		std Y+7,__zero_reg__
 125               	/* epilogue: frame size=8 */
 126 0034 2896      		adiw r28,8
 127 0036 0FB6      		in __tmp_reg__,__SREG__
 128 0038 F894      		cli
 129 003a DEBF      		out __SP_H__,r29
 130 003c 0FBE      		out __SREG__,__tmp_reg__
 131 003e CDBF      		out __SP_L__,r28
 132 0040 DF91      		pop r29
 133 0042 CF91      		pop r28
 134 0044 0895      		ret
 135               	/* epilogue end (size=9) */
 136               	/* function init_time size 35 (16) */
 138               	.Lscope0:
 141               	.global	inc_time
 143               	inc_time:
  49:ledmeter.c    **** }
  50:ledmeter.c    **** 
  51:ledmeter.c    **** void inc_time(time_t time) {
 145               	.LM6:
 146               	/* prologue: frame size=20 */
 147 0046 CF93      		push r28
 148 0048 DF93      		push r29
 149 004a CDB7      		in r28,__SP_L__
 150 004c DEB7      		in r29,__SP_H__
 151 004e 6497      		sbiw r28,20
 152 0050 0FB6      		in __tmp_reg__,__SREG__
 153 0052 F894      		cli
 154 0054 DEBF      		out __SP_H__,r29
 155 0056 0FBE      		out __SREG__,__tmp_reg__
 156 0058 CDBF      		out __SP_L__,r28
 157               	/* prologue end (size=10) */
 158 005a 2983      		std Y+1,r18
 159 005c 3A83      		std Y+2,r19
 160 005e 4B83      		std Y+3,r20
 161 0060 5C83      		std Y+4,r21
 162 0062 6D83      		std Y+5,r22
 163 0064 7E83      		std Y+6,r23
 164 0066 8F83      		std Y+7,r24
 165 0068 9887      		std Y+8,r25
  52:ledmeter.c    ****   if (running_chronometer) {
 167               	.LM7:
 168 006a 8091 0000 		lds r24,running_chronometer
 169 006e 9091 0000 		lds r25,(running_chronometer)+1
 170 0072 0097      		sbiw r24,0
 171 0074 09F4      		brne .+2
 172 0076 7BC0      		rjmp .L2
  53:ledmeter.c    ****     time.xx++;
 174               	.LM8:
 175 0078 8F81      		ldd r24,Y+7
 176 007a 9885      		ldd r25,Y+8
 177 007c 0196      		adiw r24,1
 178 007e 9887      		std Y+8,r25
 179 0080 8F83      		std Y+7,r24
  54:ledmeter.c    ****     if(time.xx >= 1000) {
 181               	.LM9:
 182 0082 8F81      		ldd r24,Y+7
 183 0084 9885      		ldd r25,Y+8
 184 0086 23E0      		ldi r18,hi8(1000)
 185 0088 883E      		cpi r24,lo8(1000)
 186 008a 9207      		cpc r25,r18
 187 008c 30F1      		brlo .L4
  55:ledmeter.c    ****         time.xx = 0;
 189               	.LM10:
 190 008e 1886      		std Y+8,__zero_reg__
 191 0090 1F82      		std Y+7,__zero_reg__
  56:ledmeter.c    ****         time.ss++;
 193               	.LM11:
 194 0092 8D81      		ldd r24,Y+5
 195 0094 9E81      		ldd r25,Y+6
 196 0096 0196      		adiw r24,1
 197 0098 9E83      		std Y+6,r25
 198 009a 8D83      		std Y+5,r24
  57:ledmeter.c    ****         if (time.ss >= 60) {
 200               	.LM12:
 201 009c 8D81      		ldd r24,Y+5
 202 009e 9E81      		ldd r25,Y+6
 203 00a0 8C33      		cpi r24,60
 204 00a2 9105      		cpc r25,__zero_reg__
 205 00a4 D4F0      		brlt .L4
  58:ledmeter.c    ****             time.ss = 0;
 207               	.LM13:
 208 00a6 1E82      		std Y+6,__zero_reg__
 209 00a8 1D82      		std Y+5,__zero_reg__
  59:ledmeter.c    ****             time.mm++;
 211               	.LM14:
 212 00aa 8B81      		ldd r24,Y+3
 213 00ac 9C81      		ldd r25,Y+4
 214 00ae 0196      		adiw r24,1
 215 00b0 9C83      		std Y+4,r25
 216 00b2 8B83      		std Y+3,r24
  60:ledmeter.c    ****             if (time.mm >= 60) {
 218               	.LM15:
 219 00b4 8B81      		ldd r24,Y+3
 220 00b6 9C81      		ldd r25,Y+4
 221 00b8 8C33      		cpi r24,60
 222 00ba 9105      		cpc r25,__zero_reg__
 223 00bc 74F0      		brlt .L4
  61:ledmeter.c    ****                 time.mm = 0;
 225               	.LM16:
 226 00be 1C82      		std Y+4,__zero_reg__
 227 00c0 1B82      		std Y+3,__zero_reg__
  62:ledmeter.c    ****                 time.hh++;
 229               	.LM17:
 230 00c2 8981      		ldd r24,Y+1
 231 00c4 9A81      		ldd r25,Y+2
 232 00c6 0196      		adiw r24,1
 233 00c8 9A83      		std Y+2,r25
 234 00ca 8983      		std Y+1,r24
  63:ledmeter.c    ****                 if (time.hh >= 24) {
 236               	.LM18:
 237 00cc 8981      		ldd r24,Y+1
 238 00ce 9A81      		ldd r25,Y+2
 239 00d0 8831      		cpi r24,24
 240 00d2 9105      		cpc r25,__zero_reg__
 241 00d4 14F0      		brlt .L4
  64:ledmeter.c    ****                     time.hh = 0;
 243               	.LM19:
 244 00d6 1A82      		std Y+2,__zero_reg__
 245 00d8 1982      		std Y+1,__zero_reg__
 246               	.L4:
 247               	.LBB2:
 249               	.Ltext1:
   1:C:/WinAVR/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:C:/WinAVR/avr/include/util/delay.h ****    Copyright (c) 2004,2005 Joerg Wunsch
   3:C:/WinAVR/avr/include/util/delay.h ****    All rights reserved.
   4:C:/WinAVR/avr/include/util/delay.h **** 
   5:C:/WinAVR/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   6:C:/WinAVR/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   7:C:/WinAVR/avr/include/util/delay.h **** 
   8:C:/WinAVR/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
   9:C:/WinAVR/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  10:C:/WinAVR/avr/include/util/delay.h **** 
  11:C:/WinAVR/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  12:C:/WinAVR/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  13:C:/WinAVR/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  14:C:/WinAVR/avr/include/util/delay.h ****      distribution.
  15:C:/WinAVR/avr/include/util/delay.h **** 
  16:C:/WinAVR/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  17:C:/WinAVR/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  18:C:/WinAVR/avr/include/util/delay.h ****      from this software without specific prior written permission.
  19:C:/WinAVR/avr/include/util/delay.h **** 
  20:C:/WinAVR/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:C:/WinAVR/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:C:/WinAVR/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:C:/WinAVR/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:C:/WinAVR/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:C:/WinAVR/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:C:/WinAVR/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:C:/WinAVR/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:C:/WinAVR/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:C:/WinAVR/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:C:/WinAVR/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:C:/WinAVR/avr/include/util/delay.h **** 
  32:C:/WinAVR/avr/include/util/delay.h **** /* $Id: delay.h,v 1.1.2.1 2005/12/12 23:19:49 joerg_wunsch Exp $ */
  33:C:/WinAVR/avr/include/util/delay.h **** 
  34:C:/WinAVR/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  35:C:/WinAVR/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  36:C:/WinAVR/avr/include/util/delay.h **** 
  37:C:/WinAVR/avr/include/util/delay.h **** #include <inttypes.h>
  38:C:/WinAVR/avr/include/util/delay.h **** 
  39:C:/WinAVR/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Busy-wait delay loops
  40:C:/WinAVR/avr/include/util/delay.h ****     \code
  41:C:/WinAVR/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  42:C:/WinAVR/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  43:C:/WinAVR/avr/include/util/delay.h ****     #include <util/delay.h>
  44:C:/WinAVR/avr/include/util/delay.h ****     \endcode
  45:C:/WinAVR/avr/include/util/delay.h **** 
  46:C:/WinAVR/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  47:C:/WinAVR/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  48:C:/WinAVR/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  49:C:/WinAVR/avr/include/util/delay.h ****     used.
  50:C:/WinAVR/avr/include/util/delay.h **** 
  51:C:/WinAVR/avr/include/util/delay.h ****     The functions in this header file implement simple delay loops
  52:C:/WinAVR/avr/include/util/delay.h ****     that perform a busy-waiting.  They are typically used to
  53:C:/WinAVR/avr/include/util/delay.h ****     facilitate short delays in the program execution.  They are
  54:C:/WinAVR/avr/include/util/delay.h ****     implemented as count-down loops with a well-known CPU cycle
  55:C:/WinAVR/avr/include/util/delay.h ****     count per loop iteration.  As such, no other processing can
  56:C:/WinAVR/avr/include/util/delay.h ****     occur simultaneously.  It should be kept in mind that the
  57:C:/WinAVR/avr/include/util/delay.h ****     functions described here do not disable interrupts.
  58:C:/WinAVR/avr/include/util/delay.h **** 
  59:C:/WinAVR/avr/include/util/delay.h ****     In general, for long delays, the use of hardware timers is
  60:C:/WinAVR/avr/include/util/delay.h ****     much preferrable, as they free the CPU, and allow for
  61:C:/WinAVR/avr/include/util/delay.h ****     concurrent processing of other events while the timer is
  62:C:/WinAVR/avr/include/util/delay.h ****     running.  However, in particular for very short delays, the
  63:C:/WinAVR/avr/include/util/delay.h ****     overhead of setting up a hardware timer is too much compared
  64:C:/WinAVR/avr/include/util/delay.h ****     to the overall delay time.
  65:C:/WinAVR/avr/include/util/delay.h **** 
  66:C:/WinAVR/avr/include/util/delay.h ****     Two inline functions are provided for the actual delay algorithms.
  67:C:/WinAVR/avr/include/util/delay.h **** 
  68:C:/WinAVR/avr/include/util/delay.h ****     Two wrapper functions allow the specification of microsecond, and
  69:C:/WinAVR/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  70:C:/WinAVR/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).  These functions
  71:C:/WinAVR/avr/include/util/delay.h ****     operate on double typed arguments, however when optimization is
  72:C:/WinAVR/avr/include/util/delay.h ****     turned on, the entire floating-point calculation will be done at
  73:C:/WinAVR/avr/include/util/delay.h ****     compile-time.
  74:C:/WinAVR/avr/include/util/delay.h **** 
  75:C:/WinAVR/avr/include/util/delay.h ****     \note When using _delay_us() and _delay_ms(), the expressions
  76:C:/WinAVR/avr/include/util/delay.h ****     passed as arguments to these functions shall be compile-time
  77:C:/WinAVR/avr/include/util/delay.h ****     constants, otherwise the floating-point calculations to setup the
  78:C:/WinAVR/avr/include/util/delay.h ****     loops will be done at run-time, thereby drastically increasing
  79:C:/WinAVR/avr/include/util/delay.h ****     both the resulting code size, as well as the time required to
  80:C:/WinAVR/avr/include/util/delay.h ****     setup the loops.
  81:C:/WinAVR/avr/include/util/delay.h **** */
  82:C:/WinAVR/avr/include/util/delay.h **** 
  83:C:/WinAVR/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:C:/WinAVR/avr/include/util/delay.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  85:C:/WinAVR/avr/include/util/delay.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  86:C:/WinAVR/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  87:C:/WinAVR/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  88:C:/WinAVR/avr/include/util/delay.h **** #endif
  89:C:/WinAVR/avr/include/util/delay.h **** 
  90:C:/WinAVR/avr/include/util/delay.h **** /** \ingroup util_delay
  91:C:/WinAVR/avr/include/util/delay.h **** 
  92:C:/WinAVR/avr/include/util/delay.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  93:C:/WinAVR/avr/include/util/delay.h ****     iterations are possible.  (The value 256 would have to be passed
  94:C:/WinAVR/avr/include/util/delay.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  95:C:/WinAVR/avr/include/util/delay.h ****     including the overhead the compiler needs to setup the counter
  96:C:/WinAVR/avr/include/util/delay.h ****     register.
  97:C:/WinAVR/avr/include/util/delay.h **** 
  98:C:/WinAVR/avr/include/util/delay.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  99:C:/WinAVR/avr/include/util/delay.h ****     can be achieved.
 100:C:/WinAVR/avr/include/util/delay.h **** */
 101:C:/WinAVR/avr/include/util/delay.h **** void
 102:C:/WinAVR/avr/include/util/delay.h **** _delay_loop_1(uint8_t __count)
 103:C:/WinAVR/avr/include/util/delay.h **** {
 104:C:/WinAVR/avr/include/util/delay.h **** 	__asm__ volatile (
 105:C:/WinAVR/avr/include/util/delay.h **** 		"1: dec %0" "\n\t"
 106:C:/WinAVR/avr/include/util/delay.h **** 		"brne 1b"
 107:C:/WinAVR/avr/include/util/delay.h **** 		: "=r" (__count)
 108:C:/WinAVR/avr/include/util/delay.h **** 		: "0" (__count)
 109:C:/WinAVR/avr/include/util/delay.h **** 	);
 110:C:/WinAVR/avr/include/util/delay.h **** }
 111:C:/WinAVR/avr/include/util/delay.h **** 
 112:C:/WinAVR/avr/include/util/delay.h **** /** \ingroup util_delay
 113:C:/WinAVR/avr/include/util/delay.h **** 
 114:C:/WinAVR/avr/include/util/delay.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
 115:C:/WinAVR/avr/include/util/delay.h ****     iterations are possible.  (The value 65536 would have to be
 116:C:/WinAVR/avr/include/util/delay.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
 117:C:/WinAVR/avr/include/util/delay.h ****     not including the overhead the compiler requires to setup the
 118:C:/WinAVR/avr/include/util/delay.h ****     counter register pair.
 119:C:/WinAVR/avr/include/util/delay.h **** 
 120:C:/WinAVR/avr/include/util/delay.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 121:C:/WinAVR/avr/include/util/delay.h ****     milliseconds can be achieved.
 122:C:/WinAVR/avr/include/util/delay.h ****  */
 123:C:/WinAVR/avr/include/util/delay.h **** void
 124:C:/WinAVR/avr/include/util/delay.h **** _delay_loop_2(uint16_t __count)
 125:C:/WinAVR/avr/include/util/delay.h **** {
 126:C:/WinAVR/avr/include/util/delay.h **** 	__asm__ volatile (
 127:C:/WinAVR/avr/include/util/delay.h **** 		"1: sbiw %0,1" "\n\t"
 128:C:/WinAVR/avr/include/util/delay.h **** 		"brne 1b"
 129:C:/WinAVR/avr/include/util/delay.h **** 		: "=w" (__count)
 130:C:/WinAVR/avr/include/util/delay.h **** 		: "0" (__count)
 131:C:/WinAVR/avr/include/util/delay.h **** 	);
 132:C:/WinAVR/avr/include/util/delay.h **** }
 133:C:/WinAVR/avr/include/util/delay.h **** 
 134:C:/WinAVR/avr/include/util/delay.h **** #ifndef F_CPU
 135:C:/WinAVR/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
 136:C:/WinAVR/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
 137:C:/WinAVR/avr/include/util/delay.h **** # define F_CPU 1000000UL
 138:C:/WinAVR/avr/include/util/delay.h **** #endif
 139:C:/WinAVR/avr/include/util/delay.h **** 
 140:C:/WinAVR/avr/include/util/delay.h **** /**
 141:C:/WinAVR/avr/include/util/delay.h ****    \ingroup util_delay
 142:C:/WinAVR/avr/include/util/delay.h **** 
 143:C:/WinAVR/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 144:C:/WinAVR/avr/include/util/delay.h **** 
 145:C:/WinAVR/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 146:C:/WinAVR/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 147:C:/WinAVR/avr/include/util/delay.h **** 
 148:C:/WinAVR/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 149:C:/WinAVR/avr/include/util/delay.h ****  */
 150:C:/WinAVR/avr/include/util/delay.h **** void
 151:C:/WinAVR/avr/include/util/delay.h **** _delay_us(double __us)
 152:C:/WinAVR/avr/include/util/delay.h **** {
 153:C:/WinAVR/avr/include/util/delay.h **** 	uint8_t __ticks;
 154:C:/WinAVR/avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 3e6) * __us;
 155:C:/WinAVR/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 156:C:/WinAVR/avr/include/util/delay.h **** 		__ticks = 1;
 157:C:/WinAVR/avr/include/util/delay.h **** 	else if (__tmp > 255)
 158:C:/WinAVR/avr/include/util/delay.h **** 		__ticks = 0;	/* i.e. 256 */
 159:C:/WinAVR/avr/include/util/delay.h **** 	else
 160:C:/WinAVR/avr/include/util/delay.h **** 		__ticks = (uint8_t)__tmp;
 161:C:/WinAVR/avr/include/util/delay.h **** 	_delay_loop_1(__ticks);
 162:C:/WinAVR/avr/include/util/delay.h **** }
 163:C:/WinAVR/avr/include/util/delay.h **** 
 164:C:/WinAVR/avr/include/util/delay.h **** 
 165:C:/WinAVR/avr/include/util/delay.h **** /**
 166:C:/WinAVR/avr/include/util/delay.h ****    \ingroup util_delay
 167:C:/WinAVR/avr/include/util/delay.h **** 
 168:C:/WinAVR/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 169:C:/WinAVR/avr/include/util/delay.h **** 
 170:C:/WinAVR/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 171:C:/WinAVR/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 172:C:/WinAVR/avr/include/util/delay.h **** 
 173:C:/WinAVR/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 174:C:/WinAVR/avr/include/util/delay.h ****  */
 175:C:/WinAVR/avr/include/util/delay.h **** void
 176:C:/WinAVR/avr/include/util/delay.h **** _delay_ms(double __ms)
 177:C:/WinAVR/avr/include/util/delay.h **** {
 251               	.LM20:
 252 00da 80E0      		ldi r24,lo8(0x3f800000)
 253 00dc 90E0      		ldi r25,hi8(0x3f800000)
 254 00de A0E8      		ldi r26,hlo8(0x3f800000)
 255 00e0 BFE3      		ldi r27,hhi8(0x3f800000)
 256 00e2 8987      		std Y+9,r24
 257 00e4 9A87      		std Y+10,r25
 258 00e6 AB87      		std Y+11,r26
 259 00e8 BC87      		std Y+12,r27
 260               	.LBB3:
 178:C:/WinAVR/avr/include/util/delay.h **** 	uint16_t __ticks;
 179:C:/WinAVR/avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 4e3) * __ms;
 262               	.LM21:
 263 00ea 20E0      		ldi r18,lo8(0x437a0000)
 264 00ec 30E0      		ldi r19,hi8(0x437a0000)
 265 00ee 4AE7      		ldi r20,hlo8(0x437a0000)
 266 00f0 53E4      		ldi r21,hhi8(0x437a0000)
 267 00f2 6985      		ldd r22,Y+9
 268 00f4 7A85      		ldd r23,Y+10
 269 00f6 8B85      		ldd r24,Y+11
 270 00f8 9C85      		ldd r25,Y+12
 271 00fa 00D0      		rcall __mulsf3
 272 00fc DC01      		movw r26,r24
 273 00fe CB01      		movw r24,r22
 274 0100 8F87      		std Y+15,r24
 275 0102 988B      		std Y+16,r25
 276 0104 A98B      		std Y+17,r26
 277 0106 BA8B      		std Y+18,r27
 180:C:/WinAVR/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 279               	.LM22:
 280 0108 20E0      		ldi r18,lo8(0x3f800000)
 281 010a 30E0      		ldi r19,hi8(0x3f800000)
 282 010c 40E8      		ldi r20,hlo8(0x3f800000)
 283 010e 5FE3      		ldi r21,hhi8(0x3f800000)
 284 0110 6F85      		ldd r22,Y+15
 285 0112 7889      		ldd r23,Y+16
 286 0114 8989      		ldd r24,Y+17
 287 0116 9A89      		ldd r25,Y+18
 288 0118 00D0      		rcall __ltsf2
 289 011a 8823      		tst r24
 290 011c 0CF0      		brlt .L9
 291 011e 05C0      		rjmp .L8
 292               	.L9:
 181:C:/WinAVR/avr/include/util/delay.h **** 		__ticks = 1;
 294               	.LM23:
 295 0120 81E0      		ldi r24,lo8(1)
 296 0122 90E0      		ldi r25,hi8(1)
 297 0124 9E87      		std Y+14,r25
 298 0126 8D87      		std Y+13,r24
 299 0128 18C0      		rjmp .L10
 300               	.L8:
 182:C:/WinAVR/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 302               	.LM24:
 303 012a 20E0      		ldi r18,lo8(0x477fff00)
 304 012c 3FEF      		ldi r19,hi8(0x477fff00)
 305 012e 4FE7      		ldi r20,hlo8(0x477fff00)
 306 0130 57E4      		ldi r21,hhi8(0x477fff00)
 307 0132 6F85      		ldd r22,Y+15
 308 0134 7889      		ldd r23,Y+16
 309 0136 8989      		ldd r24,Y+17
 310 0138 9A89      		ldd r25,Y+18
 311 013a 00D0      		rcall __gtsf2
 312 013c 1816      		cp __zero_reg__,r24
 313 013e 0CF0      		brlt .L12
 314 0140 03C0      		rjmp .L11
 315               	.L12:
 183:C:/WinAVR/avr/include/util/delay.h **** 		__ticks = 0;	/* i.e. 65536 */
 317               	.LM25:
 318 0142 1E86      		std Y+14,__zero_reg__
 319 0144 1D86      		std Y+13,__zero_reg__
 320 0146 09C0      		rjmp .L10
 321               	.L11:
 184:C:/WinAVR/avr/include/util/delay.h **** 	else
 185:C:/WinAVR/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 323               	.LM26:
 324 0148 6F85      		ldd r22,Y+15
 325 014a 7889      		ldd r23,Y+16
 326 014c 8989      		ldd r24,Y+17
 327 014e 9A89      		ldd r25,Y+18
 328 0150 00D0      		rcall __fixunssfsi
 329 0152 DC01      		movw r26,r24
 330 0154 CB01      		movw r24,r22
 331 0156 9E87      		std Y+14,r25
 332 0158 8D87      		std Y+13,r24
 333               	.L10:
 334               	.LBB4:
 336               	.LM27:
 337 015a 8D85      		ldd r24,Y+13
 338 015c 9E85      		ldd r25,Y+14
 339 015e 9C8B      		std Y+20,r25
 340 0160 8B8B      		std Y+19,r24
 341               	.LBB5:
 343               	.LM28:
 344 0162 8B89      		ldd r24,Y+19
 345 0164 9C89      		ldd r25,Y+20
 346               	/* #APP */
 347 0166 0197      		1: sbiw r24,1
 348 0168 F1F7      		brne 1b
 349               	/* #NOAPP */
 350 016a 9C8B      		std Y+20,r25
 351 016c 8B8B      		std Y+19,r24
 352               	.L2:
 353               	.LBE5:
 354               	.LBE4:
 355               	.LBE3:
 356               	.LBE2:
 357               	/* epilogue: frame size=20 */
 358 016e 6496      		adiw r28,20
 359 0170 0FB6      		in __tmp_reg__,__SREG__
 360 0172 F894      		cli
 361 0174 DEBF      		out __SP_H__,r29
 362 0176 0FBE      		out __SREG__,__tmp_reg__
 363 0178 CDBF      		out __SP_L__,r28
 364 017a DF91      		pop r29
 365 017c CF91      		pop r28
 366 017e 0895      		ret
 367               	/* epilogue end (size=9) */
 368               	/* function inc_time size 159 (140) */
 380               	.Lscope1:
 382               	.global	switch_on_all_leds
 384               	switch_on_all_leds:
 386               	.Ltext2:
  65:ledmeter.c    **** 					 }
  66:ledmeter.c    ****             }
  67:ledmeter.c    ****         }
  68:ledmeter.c    ****     }
  69:ledmeter.c    ****     _delay_ms(1);
  70:ledmeter.c    ****   }
  71:ledmeter.c    **** }
  72:ledmeter.c    **** 
  73:ledmeter.c    **** 
  74:ledmeter.c    **** 
  75:ledmeter.c    **** /*
  76:ledmeter.c    **** void switch_on_all_leds();
  77:ledmeter.c    **** void switch_off_all_leds();
  78:ledmeter.c    **** void switch_on_led(int led);
  79:ledmeter.c    **** void switch_off_led(int led);
  80:ledmeter.c    **** void loop(void);
  81:ledmeter.c    **** void init(void);
  82:ledmeter.c    **** */
  83:ledmeter.c    **** 
  84:ledmeter.c    **** // 1=off
  85:ledmeter.c    **** // 0=on
  86:ledmeter.c    **** 
  87:ledmeter.c    **** /*
  88:ledmeter.c    ****  *
  89:ledmeter.c    ****  */
  90:ledmeter.c    **** void switch_on_all_leds() {
 388               	.LM29:
 389               	/* prologue: frame size=0 */
 390 0180 CF93      		push r28
 391 0182 DF93      		push r29
 392 0184 CDB7      		in r28,__SP_L__
 393 0186 DEB7      		in r29,__SP_H__
 394               	/* prologue end (size=4) */
  91:ledmeter.c    ****     PORTC = 0x00;
 396               	.LM30:
 397 0188 1092 3500 		sts 53,__zero_reg__
 398               	/* epilogue: frame size=0 */
 399 018c DF91      		pop r29
 400 018e CF91      		pop r28
 401 0190 0895      		ret
 402               	/* epilogue end (size=3) */
 403               	/* function switch_on_all_leds size 9 (2) */
 405               	.Lscope2:
 407               	.global	switch_off_all_leds
 409               	switch_off_all_leds:
  92:ledmeter.c    **** }
  93:ledmeter.c    **** 
  94:ledmeter.c    **** /*
  95:ledmeter.c    ****  *
  96:ledmeter.c    ****  */
  97:ledmeter.c    **** void switch_off_all_leds() {
 411               	.LM31:
 412               	/* prologue: frame size=0 */
 413 0192 CF93      		push r28
 414 0194 DF93      		push r29
 415 0196 CDB7      		in r28,__SP_L__
 416 0198 DEB7      		in r29,__SP_H__
 417               	/* prologue end (size=4) */
  98:ledmeter.c    ****     PORTC = 0xFF;
 419               	.LM32:
 420 019a 8FEF      		ldi r24,lo8(-1)
 421 019c 8093 3500 		sts 53,r24
 422               	/* epilogue: frame size=0 */
 423 01a0 DF91      		pop r29
 424 01a2 CF91      		pop r28
 425 01a4 0895      		ret
 426               	/* epilogue end (size=3) */
 427               	/* function switch_off_all_leds size 10 (3) */
 429               	.Lscope3:
 432               	.global	switch_on_led
 434               	switch_on_led:
  99:ledmeter.c    **** }
 100:ledmeter.c    **** 
 101:ledmeter.c    **** // led from 1 to 8 (LEDSNUM)
 102:ledmeter.c    **** // PCx with w from 0 to 7
 103:ledmeter.c    **** 
 104:ledmeter.c    **** /*
 105:ledmeter.c    ****  *  switch on the led with the number called "led"
 106:ledmeter.c    ****  */
 107:ledmeter.c    **** void switch_on_led(int led) {
 436               	.LM33:
 437               	/* prologue: frame size=6 */
 438 01a6 CF93      		push r28
 439 01a8 DF93      		push r29
 440 01aa CDB7      		in r28,__SP_L__
 441 01ac DEB7      		in r29,__SP_H__
 442 01ae 2697      		sbiw r28,6
 443 01b0 0FB6      		in __tmp_reg__,__SREG__
 444 01b2 F894      		cli
 445 01b4 DEBF      		out __SP_H__,r29
 446 01b6 0FBE      		out __SREG__,__tmp_reg__
 447 01b8 CDBF      		out __SP_L__,r28
 448               	/* prologue end (size=10) */
 449 01ba 9A83      		std Y+2,r25
 450 01bc 8983      		std Y+1,r24
 108:ledmeter.c    ****     int pin = led - 1;
 452               	.LM34:
 453 01be 8981      		ldd r24,Y+1
 454 01c0 9A81      		ldd r25,Y+2
 455 01c2 0197      		sbiw r24,1
 456 01c4 9C83      		std Y+4,r25
 457 01c6 8B83      		std Y+3,r24
 109:ledmeter.c    ****     int mask = ~(1<<pin);
 459               	.LM35:
 460 01c8 81E0      		ldi r24,lo8(1)
 461 01ca 90E0      		ldi r25,hi8(1)
 462 01cc 0B80      		ldd r0,Y+3
 463 01ce 02C0      		rjmp 2f
 464 01d0 880F      	1:	lsl r24
 465 01d2 991F      		rol r25
 466 01d4 0A94      	2:	dec r0
 467 01d6 E2F7      		brpl 1b
 468 01d8 8095      		com r24
 469 01da 9095      		com r25
 470 01dc 9E83      		std Y+6,r25
 471 01de 8D83      		std Y+5,r24
 110:ledmeter.c    ****     PORTC&=mask;
 473               	.LM36:
 474 01e0 9091 3500 		lds r25,53
 475 01e4 8D81      		ldd r24,Y+5
 476 01e6 8923      		and r24,r25
 477 01e8 8093 3500 		sts 53,r24
 478               	/* epilogue: frame size=6 */
 479 01ec 2696      		adiw r28,6
 480 01ee 0FB6      		in __tmp_reg__,__SREG__
 481 01f0 F894      		cli
 482 01f2 DEBF      		out __SP_H__,r29
 483 01f4 0FBE      		out __SREG__,__tmp_reg__
 484 01f6 CDBF      		out __SP_L__,r28
 485 01f8 DF91      		pop r29
 486 01fa CF91      		pop r28
 487 01fc 0895      		ret
 488               	/* epilogue end (size=9) */
 489               	/* function switch_on_led size 44 (25) */
 495               	.Lscope4:
 498               	.global	switch_off_led
 500               	switch_off_led:
 111:ledmeter.c    **** }
 112:ledmeter.c    **** 
 113:ledmeter.c    **** /*
 114:ledmeter.c    ****  *  switch off the led with the number called "led"
 115:ledmeter.c    ****  */
 116:ledmeter.c    **** void switch_off_led(int led) {
 502               	.LM37:
 503               	/* prologue: frame size=6 */
 504 01fe CF93      		push r28
 505 0200 DF93      		push r29
 506 0202 CDB7      		in r28,__SP_L__
 507 0204 DEB7      		in r29,__SP_H__
 508 0206 2697      		sbiw r28,6
 509 0208 0FB6      		in __tmp_reg__,__SREG__
 510 020a F894      		cli
 511 020c DEBF      		out __SP_H__,r29
 512 020e 0FBE      		out __SREG__,__tmp_reg__
 513 0210 CDBF      		out __SP_L__,r28
 514               	/* prologue end (size=10) */
 515 0212 9A83      		std Y+2,r25
 516 0214 8983      		std Y+1,r24
 117:ledmeter.c    ****     int pin = led - 1;
 518               	.LM38:
 519 0216 8981      		ldd r24,Y+1
 520 0218 9A81      		ldd r25,Y+2
 521 021a 0197      		sbiw r24,1
 522 021c 9C83      		std Y+4,r25
 523 021e 8B83      		std Y+3,r24
 118:ledmeter.c    ****     int mask = (1<<pin);
 525               	.LM39:
 526 0220 81E0      		ldi r24,lo8(1)
 527 0222 90E0      		ldi r25,hi8(1)
 528 0224 0B80      		ldd r0,Y+3
 529 0226 02C0      		rjmp 2f
 530 0228 880F      	1:	lsl r24
 531 022a 991F      		rol r25
 532 022c 0A94      	2:	dec r0
 533 022e E2F7      		brpl 1b
 534 0230 9E83      		std Y+6,r25
 535 0232 8D83      		std Y+5,r24
 119:ledmeter.c    ****     PORTC|=mask;
 537               	.LM40:
 538 0234 9091 3500 		lds r25,53
 539 0238 8D81      		ldd r24,Y+5
 540 023a 892B      		or r24,r25
 541 023c 8093 3500 		sts 53,r24
 542               	/* epilogue: frame size=6 */
 543 0240 2696      		adiw r28,6
 544 0242 0FB6      		in __tmp_reg__,__SREG__
 545 0244 F894      		cli
 546 0246 DEBF      		out __SP_H__,r29
 547 0248 0FBE      		out __SREG__,__tmp_reg__
 548 024a CDBF      		out __SP_L__,r28
 549 024c DF91      		pop r29
 550 024e CF91      		pop r28
 551 0250 0895      		ret
 552               	/* epilogue end (size=9) */
 553               	/* function switch_off_led size 42 (23) */
 559               	.Lscope5:
 562               	.global	switch_on_leds_with_delay
 564               	switch_on_leds_with_delay:
 120:ledmeter.c    **** }
 121:ledmeter.c    **** 
 122:ledmeter.c    **** /*
 123:ledmeter.c    ****  *  switch on every leds one after one with a delay (called "delay")
 124:ledmeter.c    ****  */
 125:ledmeter.c    **** void switch_on_leds_with_delay(double delay) {
 566               	.LM41:
 567               	/* prologue: frame size=18 */
 568 0252 CF93      		push r28
 569 0254 DF93      		push r29
 570 0256 CDB7      		in r28,__SP_L__
 571 0258 DEB7      		in r29,__SP_H__
 572 025a 6297      		sbiw r28,18
 573 025c 0FB6      		in __tmp_reg__,__SREG__
 574 025e F894      		cli
 575 0260 DEBF      		out __SP_H__,r29
 576 0262 0FBE      		out __SREG__,__tmp_reg__
 577 0264 CDBF      		out __SP_L__,r28
 578               	/* prologue end (size=10) */
 579 0266 6983      		std Y+1,r22
 580 0268 7A83      		std Y+2,r23
 581 026a 8B83      		std Y+3,r24
 582 026c 9C83      		std Y+4,r25
 126:ledmeter.c    ****     int i;
 127:ledmeter.c    ****     for(i = 1; i<=Nleds; i++) {
 584               	.LM42:
 585 026e 81E0      		ldi r24,lo8(1)
 586 0270 90E0      		ldi r25,hi8(1)
 587 0272 9E83      		std Y+6,r25
 588 0274 8D83      		std Y+5,r24
 589               	.L21:
 591               	.LM43:
 592 0276 8D81      		ldd r24,Y+5
 593 0278 9E81      		ldd r25,Y+6
 594 027a 8930      		cpi r24,9
 595 027c 9105      		cpc r25,__zero_reg__
 596 027e 0CF0      		brlt .+2
 597 0280 53C0      		rjmp .L20
 598               	.LBB6:
 600               	.Ltext3:
 602               	.LM44:
 603 0282 8981      		ldd r24,Y+1
 604 0284 9A81      		ldd r25,Y+2
 605 0286 AB81      		ldd r26,Y+3
 606 0288 BC81      		ldd r27,Y+4
 607 028a 8F83      		std Y+7,r24
 608 028c 9887      		std Y+8,r25
 609 028e A987      		std Y+9,r26
 610 0290 BA87      		std Y+10,r27
 611               	.LBB7:
 613               	.LM45:
 614 0292 20E0      		ldi r18,lo8(0x437a0000)
 615 0294 30E0      		ldi r19,hi8(0x437a0000)
 616 0296 4AE7      		ldi r20,hlo8(0x437a0000)
 617 0298 53E4      		ldi r21,hhi8(0x437a0000)
 618 029a 6F81      		ldd r22,Y+7
 619 029c 7885      		ldd r23,Y+8
 620 029e 8985      		ldd r24,Y+9
 621 02a0 9A85      		ldd r25,Y+10
 622 02a2 00D0      		rcall __mulsf3
 623 02a4 DC01      		movw r26,r24
 624 02a6 CB01      		movw r24,r22
 625 02a8 8D87      		std Y+13,r24
 626 02aa 9E87      		std Y+14,r25
 627 02ac AF87      		std Y+15,r26
 628 02ae B88B      		std Y+16,r27
 630               	.LM46:
 631 02b0 20E0      		ldi r18,lo8(0x3f800000)
 632 02b2 30E0      		ldi r19,hi8(0x3f800000)
 633 02b4 40E8      		ldi r20,hlo8(0x3f800000)
 634 02b6 5FE3      		ldi r21,hhi8(0x3f800000)
 635 02b8 6D85      		ldd r22,Y+13
 636 02ba 7E85      		ldd r23,Y+14
 637 02bc 8F85      		ldd r24,Y+15
 638 02be 9889      		ldd r25,Y+16
 639 02c0 00D0      		rcall __ltsf2
 640 02c2 8823      		tst r24
 641 02c4 0CF0      		brlt .L25
 642 02c6 05C0      		rjmp .L24
 643               	.L25:
 645               	.LM47:
 646 02c8 81E0      		ldi r24,lo8(1)
 647 02ca 90E0      		ldi r25,hi8(1)
 648 02cc 9C87      		std Y+12,r25
 649 02ce 8B87      		std Y+11,r24
 650 02d0 18C0      		rjmp .L26
 651               	.L24:
 653               	.LM48:
 654 02d2 20E0      		ldi r18,lo8(0x477fff00)
 655 02d4 3FEF      		ldi r19,hi8(0x477fff00)
 656 02d6 4FE7      		ldi r20,hlo8(0x477fff00)
 657 02d8 57E4      		ldi r21,hhi8(0x477fff00)
 658 02da 6D85      		ldd r22,Y+13
 659 02dc 7E85      		ldd r23,Y+14
 660 02de 8F85      		ldd r24,Y+15
 661 02e0 9889      		ldd r25,Y+16
 662 02e2 00D0      		rcall __gtsf2
 663 02e4 1816      		cp __zero_reg__,r24
 664 02e6 0CF0      		brlt .L28
 665 02e8 03C0      		rjmp .L27
 666               	.L28:
 668               	.LM49:
 669 02ea 1C86      		std Y+12,__zero_reg__
 670 02ec 1B86      		std Y+11,__zero_reg__
 671 02ee 09C0      		rjmp .L26
 672               	.L27:
 674               	.LM50:
 675 02f0 6D85      		ldd r22,Y+13
 676 02f2 7E85      		ldd r23,Y+14
 677 02f4 8F85      		ldd r24,Y+15
 678 02f6 9889      		ldd r25,Y+16
 679 02f8 00D0      		rcall __fixunssfsi
 680 02fa DC01      		movw r26,r24
 681 02fc CB01      		movw r24,r22
 682 02fe 9C87      		std Y+12,r25
 683 0300 8B87      		std Y+11,r24
 684               	.L26:
 685               	.LBB8:
 687               	.LM51:
 688 0302 8B85      		ldd r24,Y+11
 689 0304 9C85      		ldd r25,Y+12
 690 0306 9A8B      		std Y+18,r25
 691 0308 898B      		std Y+17,r24
 692               	.LBB9:
 694               	.LM52:
 695 030a 8989      		ldd r24,Y+17
 696 030c 9A89      		ldd r25,Y+18
 697               	/* #APP */
 698 030e 0197      		1: sbiw r24,1
 699 0310 F1F7      		brne 1b
 700               	/* #NOAPP */
 701 0312 9A8B      		std Y+18,r25
 702 0314 898B      		std Y+17,r24
 703               	.LBE9:
 704               	.LBE8:
 705               	.LBE7:
 706               	.LBE6:
 708               	.Ltext4:
 128:ledmeter.c    ****         _delay_ms(delay);
 129:ledmeter.c    ****         switch_on_led(i);
 710               	.LM53:
 711 0316 8D81      		ldd r24,Y+5
 712 0318 9E81      		ldd r25,Y+6
 713 031a 45DF      		rcall switch_on_led
 715               	.LM54:
 716 031c 8D81      		ldd r24,Y+5
 717 031e 9E81      		ldd r25,Y+6
 718 0320 0196      		adiw r24,1
 719 0322 9E83      		std Y+6,r25
 720 0324 8D83      		std Y+5,r24
 721 0326 A7CF      		rjmp .L21
 722               	.L20:
 723               	/* epilogue: frame size=18 */
 724 0328 6296      		adiw r28,18
 725 032a 0FB6      		in __tmp_reg__,__SREG__
 726 032c F894      		cli
 727 032e DEBF      		out __SP_H__,r29
 728 0330 0FBE      		out __SREG__,__tmp_reg__
 729 0332 CDBF      		out __SP_L__,r28
 730 0334 DF91      		pop r29
 731 0336 CF91      		pop r28
 732 0338 0895      		ret
 733               	/* epilogue end (size=9) */
 734               	/* function switch_on_leds_with_delay size 118 (99) */
 749               	.Lscope6:
 752               	.global	switch_off_leds_with_delay
 754               	switch_off_leds_with_delay:
 130:ledmeter.c    ****     }
 131:ledmeter.c    **** }
 132:ledmeter.c    **** 
 133:ledmeter.c    **** /*
 134:ledmeter.c    ****  *  switch off every leds on after one with a delay (called "delay")
 135:ledmeter.c    ****  */
 136:ledmeter.c    **** void switch_off_leds_with_delay(double delay) {
 756               	.LM55:
 757               	/* prologue: frame size=18 */
 758 033a CF93      		push r28
 759 033c DF93      		push r29
 760 033e CDB7      		in r28,__SP_L__
 761 0340 DEB7      		in r29,__SP_H__
 762 0342 6297      		sbiw r28,18
 763 0344 0FB6      		in __tmp_reg__,__SREG__
 764 0346 F894      		cli
 765 0348 DEBF      		out __SP_H__,r29
 766 034a 0FBE      		out __SREG__,__tmp_reg__
 767 034c CDBF      		out __SP_L__,r28
 768               	/* prologue end (size=10) */
 769 034e 6983      		std Y+1,r22
 770 0350 7A83      		std Y+2,r23
 771 0352 8B83      		std Y+3,r24
 772 0354 9C83      		std Y+4,r25
 137:ledmeter.c    ****     int i;
 138:ledmeter.c    ****     for(i = Nleds; i>=0; i--) {
 774               	.LM56:
 775 0356 88E0      		ldi r24,lo8(8)
 776 0358 90E0      		ldi r25,hi8(8)
 777 035a 9E83      		std Y+6,r25
 778 035c 8D83      		std Y+5,r24
 779               	.L33:
 781               	.LM57:
 782 035e 8D81      		ldd r24,Y+5
 783 0360 9E81      		ldd r25,Y+6
 784 0362 9923      		tst r25
 785 0364 0CF4      		brge .+2
 786 0366 53C0      		rjmp .L32
 787               	.LBB10:
 789               	.Ltext5:
 791               	.LM58:
 792 0368 8981      		ldd r24,Y+1
 793 036a 9A81      		ldd r25,Y+2
 794 036c AB81      		ldd r26,Y+3
 795 036e BC81      		ldd r27,Y+4
 796 0370 8F83      		std Y+7,r24
 797 0372 9887      		std Y+8,r25
 798 0374 A987      		std Y+9,r26
 799 0376 BA87      		std Y+10,r27
 800               	.LBB11:
 802               	.LM59:
 803 0378 20E0      		ldi r18,lo8(0x437a0000)
 804 037a 30E0      		ldi r19,hi8(0x437a0000)
 805 037c 4AE7      		ldi r20,hlo8(0x437a0000)
 806 037e 53E4      		ldi r21,hhi8(0x437a0000)
 807 0380 6F81      		ldd r22,Y+7
 808 0382 7885      		ldd r23,Y+8
 809 0384 8985      		ldd r24,Y+9
 810 0386 9A85      		ldd r25,Y+10
 811 0388 00D0      		rcall __mulsf3
 812 038a DC01      		movw r26,r24
 813 038c CB01      		movw r24,r22
 814 038e 8D87      		std Y+13,r24
 815 0390 9E87      		std Y+14,r25
 816 0392 AF87      		std Y+15,r26
 817 0394 B88B      		std Y+16,r27
 819               	.LM60:
 820 0396 20E0      		ldi r18,lo8(0x3f800000)
 821 0398 30E0      		ldi r19,hi8(0x3f800000)
 822 039a 40E8      		ldi r20,hlo8(0x3f800000)
 823 039c 5FE3      		ldi r21,hhi8(0x3f800000)
 824 039e 6D85      		ldd r22,Y+13
 825 03a0 7E85      		ldd r23,Y+14
 826 03a2 8F85      		ldd r24,Y+15
 827 03a4 9889      		ldd r25,Y+16
 828 03a6 00D0      		rcall __ltsf2
 829 03a8 8823      		tst r24
 830 03aa 0CF0      		brlt .L37
 831 03ac 05C0      		rjmp .L36
 832               	.L37:
 834               	.LM61:
 835 03ae 81E0      		ldi r24,lo8(1)
 836 03b0 90E0      		ldi r25,hi8(1)
 837 03b2 9C87      		std Y+12,r25
 838 03b4 8B87      		std Y+11,r24
 839 03b6 18C0      		rjmp .L38
 840               	.L36:
 842               	.LM62:
 843 03b8 20E0      		ldi r18,lo8(0x477fff00)
 844 03ba 3FEF      		ldi r19,hi8(0x477fff00)
 845 03bc 4FE7      		ldi r20,hlo8(0x477fff00)
 846 03be 57E4      		ldi r21,hhi8(0x477fff00)
 847 03c0 6D85      		ldd r22,Y+13
 848 03c2 7E85      		ldd r23,Y+14
 849 03c4 8F85      		ldd r24,Y+15
 850 03c6 9889      		ldd r25,Y+16
 851 03c8 00D0      		rcall __gtsf2
 852 03ca 1816      		cp __zero_reg__,r24
 853 03cc 0CF0      		brlt .L40
 854 03ce 03C0      		rjmp .L39
 855               	.L40:
 857               	.LM63:
 858 03d0 1C86      		std Y+12,__zero_reg__
 859 03d2 1B86      		std Y+11,__zero_reg__
 860 03d4 09C0      		rjmp .L38
 861               	.L39:
 863               	.LM64:
 864 03d6 6D85      		ldd r22,Y+13
 865 03d8 7E85      		ldd r23,Y+14
 866 03da 8F85      		ldd r24,Y+15
 867 03dc 9889      		ldd r25,Y+16
 868 03de 00D0      		rcall __fixunssfsi
 869 03e0 DC01      		movw r26,r24
 870 03e2 CB01      		movw r24,r22
 871 03e4 9C87      		std Y+12,r25
 872 03e6 8B87      		std Y+11,r24
 873               	.L38:
 874               	.LBB12:
 876               	.LM65:
 877 03e8 8B85      		ldd r24,Y+11
 878 03ea 9C85      		ldd r25,Y+12
 879 03ec 9A8B      		std Y+18,r25
 880 03ee 898B      		std Y+17,r24
 881               	.LBB13:
 883               	.LM66:
 884 03f0 8989      		ldd r24,Y+17
 885 03f2 9A89      		ldd r25,Y+18
 886               	/* #APP */
 887 03f4 0197      		1: sbiw r24,1
 888 03f6 F1F7      		brne 1b
 889               	/* #NOAPP */
 890 03f8 9A8B      		std Y+18,r25
 891 03fa 898B      		std Y+17,r24
 892               	.LBE13:
 893               	.LBE12:
 894               	.LBE11:
 895               	.LBE10:
 897               	.Ltext6:
 139:ledmeter.c    ****         _delay_ms(delay);
 140:ledmeter.c    ****         switch_off_led(i);
 899               	.LM67:
 900 03fc 8D81      		ldd r24,Y+5
 901 03fe 9E81      		ldd r25,Y+6
 902 0400 FEDE      		rcall switch_off_led
 904               	.LM68:
 905 0402 8D81      		ldd r24,Y+5
 906 0404 9E81      		ldd r25,Y+6
 907 0406 0197      		sbiw r24,1
 908 0408 9E83      		std Y+6,r25
 909 040a 8D83      		std Y+5,r24
 910 040c A8CF      		rjmp .L33
 911               	.L32:
 912               	/* epilogue: frame size=18 */
 913 040e 6296      		adiw r28,18
 914 0410 0FB6      		in __tmp_reg__,__SREG__
 915 0412 F894      		cli
 916 0414 DEBF      		out __SP_H__,r29
 917 0416 0FBE      		out __SREG__,__tmp_reg__
 918 0418 CDBF      		out __SP_L__,r28
 919 041a DF91      		pop r29
 920 041c CF91      		pop r28
 921 041e 0895      		ret
 922               	/* epilogue end (size=9) */
 923               	/* function switch_off_leds_with_delay size 117 (98) */
 938               	.Lscope7:
 940               	.global	test_leds
 942               	test_leds:
 141:ledmeter.c    ****     }
 142:ledmeter.c    **** }
 143:ledmeter.c    **** 
 144:ledmeter.c    **** /*
 145:ledmeter.c    ****  * a function for testing leds that switch on every leds and switch off every leds (one after one)
 146:ledmeter.c    ****  */
 147:ledmeter.c    **** void test_leds() {
 944               	.LM69:
 945               	/* prologue: frame size=12 */
 946 0420 CF93      		push r28
 947 0422 DF93      		push r29
 948 0424 CDB7      		in r28,__SP_L__
 949 0426 DEB7      		in r29,__SP_H__
 950 0428 2C97      		sbiw r28,12
 951 042a 0FB6      		in __tmp_reg__,__SREG__
 952 042c F894      		cli
 953 042e DEBF      		out __SP_H__,r29
 954 0430 0FBE      		out __SREG__,__tmp_reg__
 955 0432 CDBF      		out __SP_L__,r28
 956               	/* prologue end (size=10) */
 148:ledmeter.c    ****     switch_on_leds_with_delay(100);
 958               	.LM70:
 959 0434 60E0      		ldi r22,lo8(0x42c80000)
 960 0436 70E0      		ldi r23,hi8(0x42c80000)
 961 0438 88EC      		ldi r24,hlo8(0x42c80000)
 962 043a 92E4      		ldi r25,hhi8(0x42c80000)
 963 043c 0ADF      		rcall switch_on_leds_with_delay
 964               	.LBB14:
 966               	.Ltext7:
 968               	.LM71:
 969 043e 80E0      		ldi r24,lo8(0x42480000)
 970 0440 90E0      		ldi r25,hi8(0x42480000)
 971 0442 A8E4      		ldi r26,hlo8(0x42480000)
 972 0444 B2E4      		ldi r27,hhi8(0x42480000)
 973 0446 8983      		std Y+1,r24
 974 0448 9A83      		std Y+2,r25
 975 044a AB83      		std Y+3,r26
 976 044c BC83      		std Y+4,r27
 977               	.LBB15:
 979               	.LM72:
 980 044e 20E0      		ldi r18,lo8(0x437a0000)
 981 0450 30E0      		ldi r19,hi8(0x437a0000)
 982 0452 4AE7      		ldi r20,hlo8(0x437a0000)
 983 0454 53E4      		ldi r21,hhi8(0x437a0000)
 984 0456 6981      		ldd r22,Y+1
 985 0458 7A81      		ldd r23,Y+2
 986 045a 8B81      		ldd r24,Y+3
 987 045c 9C81      		ldd r25,Y+4
 988 045e 00D0      		rcall __mulsf3
 989 0460 DC01      		movw r26,r24
 990 0462 CB01      		movw r24,r22
 991 0464 8F83      		std Y+7,r24
 992 0466 9887      		std Y+8,r25
 993 0468 A987      		std Y+9,r26
 994 046a BA87      		std Y+10,r27
 996               	.LM73:
 997 046c 20E0      		ldi r18,lo8(0x3f800000)
 998 046e 30E0      		ldi r19,hi8(0x3f800000)
 999 0470 40E8      		ldi r20,hlo8(0x3f800000)
 1000 0472 5FE3      		ldi r21,hhi8(0x3f800000)
 1001 0474 6F81      		ldd r22,Y+7
 1002 0476 7885      		ldd r23,Y+8
 1003 0478 8985      		ldd r24,Y+9
 1004 047a 9A85      		ldd r25,Y+10
 1005 047c 00D0      		rcall __ltsf2
 1006 047e 8823      		tst r24
 1007 0480 0CF0      		brlt .L46
 1009               	.LM74:
 1010 0482 05C0      		rjmp .L45
 1011               	.L46:
 1013               	.LM75:
 1014 0484 81E0      		ldi r24,lo8(1)
 1015 0486 90E0      		ldi r25,hi8(1)
 1016 0488 9E83      		std Y+6,r25
 1017 048a 8D83      		std Y+5,r24
 1018 048c 18C0      		rjmp .L47
 1019               	.L45:
 1021               	.LM76:
 1022 048e 20E0      		ldi r18,lo8(0x477fff00)
 1023 0490 3FEF      		ldi r19,hi8(0x477fff00)
 1024 0492 4FE7      		ldi r20,hlo8(0x477fff00)
 1025 0494 57E4      		ldi r21,hhi8(0x477fff00)
 1026 0496 6F81      		ldd r22,Y+7
 1027 0498 7885      		ldd r23,Y+8
 1028 049a 8985      		ldd r24,Y+9
 1029 049c 9A85      		ldd r25,Y+10
 1030 049e 00D0      		rcall __gtsf2
 1031 04a0 1816      		cp __zero_reg__,r24
 1032 04a2 0CF0      		brlt .L49
 1033 04a4 03C0      		rjmp .L48
 1034               	.L49:
 1036               	.LM77:
 1037 04a6 1E82      		std Y+6,__zero_reg__
 1038 04a8 1D82      		std Y+5,__zero_reg__
 1039 04aa 09C0      		rjmp .L47
 1040               	.L48:
 1042               	.LM78:
 1043 04ac 6F81      		ldd r22,Y+7
 1044 04ae 7885      		ldd r23,Y+8
 1045 04b0 8985      		ldd r24,Y+9
 1046 04b2 9A85      		ldd r25,Y+10
 1047 04b4 00D0      		rcall __fixunssfsi
 1048 04b6 DC01      		movw r26,r24
 1049 04b8 CB01      		movw r24,r22
 1050 04ba 9E83      		std Y+6,r25
 1051 04bc 8D83      		std Y+5,r24
 1052               	.L47:
 1053               	.LBB16:
 1055               	.LM79:
 1056 04be 8D81      		ldd r24,Y+5
 1057 04c0 9E81      		ldd r25,Y+6
 1058 04c2 9C87      		std Y+12,r25
 1059 04c4 8B87      		std Y+11,r24
 1060               	.LBB17:
 1062               	.LM80:
 1063 04c6 8B85      		ldd r24,Y+11
 1064 04c8 9C85      		ldd r25,Y+12
 1065               	/* #APP */
 1066 04ca 0197      		1: sbiw r24,1
 1067 04cc F1F7      		brne 1b
 1068               	/* #NOAPP */
 1069 04ce 9C87      		std Y+12,r25
 1070 04d0 8B87      		std Y+11,r24
 1071               	.LBE17:
 1072               	.LBE16:
 1073               	.LBE15:
 1074               	.LBE14:
 1076               	.Ltext8:
 149:ledmeter.c    ****     _delay_ms(50);
 150:ledmeter.c    ****     switch_off_leds_with_delay(100);
 1078               	.LM81:
 1079 04d2 60E0      		ldi r22,lo8(0x42c80000)
 1080 04d4 70E0      		ldi r23,hi8(0x42c80000)
 1081 04d6 88EC      		ldi r24,hlo8(0x42c80000)
 1082 04d8 92E4      		ldi r25,hhi8(0x42c80000)
 1083 04da 2FDF      		rcall switch_off_leds_with_delay
 1084               	/* epilogue: frame size=12 */
 1085 04dc 2C96      		adiw r28,12
 1086 04de 0FB6      		in __tmp_reg__,__SREG__
 1087 04e0 F894      		cli
 1088 04e2 DEBF      		out __SP_H__,r29
 1089 04e4 0FBE      		out __SREG__,__tmp_reg__
 1090 04e6 CDBF      		out __SP_L__,r28
 1091 04e8 DF91      		pop r29
 1092 04ea CF91      		pop r28
 1093 04ec 0895      		ret
 1094               	/* epilogue end (size=9) */
 1095               	/* function test_leds size 105 (86) */
 1107               	.Lscope8:
 1110               	.global	switch_on_min_dels
 1112               	switch_on_min_dels:
 151:ledmeter.c    **** }
 152:ledmeter.c    **** 
 153:ledmeter.c    **** /*
 154:ledmeter.c    ****  *  switch on every leds (from 0 to n)  (and switch off others)
 155:ledmeter.c    ****  */
 156:ledmeter.c    **** void switch_on_min_dels(int n) {
 1114               	.LM82:
 1115               	/* prologue: frame size=4 */
 1116 04ee CF93      		push r28
 1117 04f0 DF93      		push r29
 1118 04f2 CDB7      		in r28,__SP_L__
 1119 04f4 DEB7      		in r29,__SP_H__
 1120 04f6 2497      		sbiw r28,4
 1121 04f8 0FB6      		in __tmp_reg__,__SREG__
 1122 04fa F894      		cli
 1123 04fc DEBF      		out __SP_H__,r29
 1124 04fe 0FBE      		out __SREG__,__tmp_reg__
 1125 0500 CDBF      		out __SP_L__,r28
 1126               	/* prologue end (size=10) */
 1127 0502 9A83      		std Y+2,r25
 1128 0504 8983      		std Y+1,r24
 157:ledmeter.c    ****     int i;
 158:ledmeter.c    ****     for(i = 1; i<=Nleds; i++) {
 1130               	.LM83:
 1131 0506 81E0      		ldi r24,lo8(1)
 1132 0508 90E0      		ldi r25,hi8(1)
 1133 050a 9C83      		std Y+4,r25
 1134 050c 8B83      		std Y+3,r24
 1135               	.L54:
 1137               	.LM84:
 1138 050e 8B81      		ldd r24,Y+3
 1139 0510 9C81      		ldd r25,Y+4
 1140 0512 8930      		cpi r24,9
 1141 0514 9105      		cpc r25,__zero_reg__
 1142 0516 A4F4      		brge .L53
 159:ledmeter.c    ****         if (i<=n) {
 1144               	.LM85:
 1145 0518 2B81      		ldd r18,Y+3
 1146 051a 3C81      		ldd r19,Y+4
 1147 051c 8981      		ldd r24,Y+1
 1148 051e 9A81      		ldd r25,Y+2
 1149 0520 8217      		cp r24,r18
 1150 0522 9307      		cpc r25,r19
 1151 0524 24F0      		brlt .L57
 160:ledmeter.c    ****             switch_on_led(i);
 1153               	.LM86:
 1154 0526 8B81      		ldd r24,Y+3
 1155 0528 9C81      		ldd r25,Y+4
 1156 052a 3DDE      		rcall switch_on_led
 1157 052c 03C0      		rjmp .L56
 1158               	.L57:
 161:ledmeter.c    ****         } else {
 162:ledmeter.c    ****             switch_off_led(i);
 1160               	.LM87:
 1161 052e 8B81      		ldd r24,Y+3
 1162 0530 9C81      		ldd r25,Y+4
 1163 0532 65DE      		rcall switch_off_led
 1164               	.L56:
 1166               	.LM88:
 1167 0534 8B81      		ldd r24,Y+3
 1168 0536 9C81      		ldd r25,Y+4
 1169 0538 0196      		adiw r24,1
 1170 053a 9C83      		std Y+4,r25
 1171 053c 8B83      		std Y+3,r24
 1172 053e E7CF      		rjmp .L54
 1173               	.L53:
 1174               	/* epilogue: frame size=4 */
 1175 0540 2496      		adiw r28,4
 1176 0542 0FB6      		in __tmp_reg__,__SREG__
 1177 0544 F894      		cli
 1178 0546 DEBF      		out __SP_H__,r29
 1179 0548 0FBE      		out __SREG__,__tmp_reg__
 1180 054a CDBF      		out __SP_L__,r28
 1181 054c DF91      		pop r29
 1182 054e CF91      		pop r28
 1183 0550 0895      		ret
 1184               	/* epilogue end (size=9) */
 1185               	/* function switch_on_min_dels size 50 (31) */
 1190               	.Lscope9:
 1193               	.global	switch_on_max_dels
 1195               	switch_on_max_dels:
 163:ledmeter.c    ****         }
 164:ledmeter.c    ****     }
 165:ledmeter.c    **** }
 166:ledmeter.c    **** 
 167:ledmeter.c    **** /*
 168:ledmeter.c    ****  *  switch on every leds (from Nleds to n)
 169:ledmeter.c    ****  */
 170:ledmeter.c    **** void switch_on_max_dels(int n) {
 1197               	.LM89:
 1198               	/* prologue: frame size=4 */
 1199 0552 CF93      		push r28
 1200 0554 DF93      		push r29
 1201 0556 CDB7      		in r28,__SP_L__
 1202 0558 DEB7      		in r29,__SP_H__
 1203 055a 2497      		sbiw r28,4
 1204 055c 0FB6      		in __tmp_reg__,__SREG__
 1205 055e F894      		cli
 1206 0560 DEBF      		out __SP_H__,r29
 1207 0562 0FBE      		out __SREG__,__tmp_reg__
 1208 0564 CDBF      		out __SP_L__,r28
 1209               	/* prologue end (size=10) */
 1210 0566 9A83      		std Y+2,r25
 1211 0568 8983      		std Y+1,r24
 171:ledmeter.c    ****     int i;
 172:ledmeter.c    ****     for(i = Nleds; i>=0; i--) {
 1213               	.LM90:
 1214 056a 88E0      		ldi r24,lo8(8)
 1215 056c 90E0      		ldi r25,hi8(8)
 1216 056e 9C83      		std Y+4,r25
 1217 0570 8B83      		std Y+3,r24
 1218               	.L60:
 1220               	.LM91:
 1221 0572 8B81      		ldd r24,Y+3
 1222 0574 9C81      		ldd r25,Y+4
 1223 0576 9923      		tst r25
 1224 0578 C4F0      		brlt .L59
 173:ledmeter.c    ****         if (i>=Nleds-n) {
 1226               	.LM92:
 1227 057a 28E0      		ldi r18,lo8(8)
 1228 057c 30E0      		ldi r19,hi8(8)
 1229 057e 8981      		ldd r24,Y+1
 1230 0580 9A81      		ldd r25,Y+2
 1231 0582 281B      		sub r18,r24
 1232 0584 390B      		sbc r19,r25
 1233 0586 8B81      		ldd r24,Y+3
 1234 0588 9C81      		ldd r25,Y+4
 1235 058a 8217      		cp r24,r18
 1236 058c 9307      		cpc r25,r19
 1237 058e 24F0      		brlt .L63
 174:ledmeter.c    ****             switch_on_led(i);
 1239               	.LM93:
 1240 0590 8B81      		ldd r24,Y+3
 1241 0592 9C81      		ldd r25,Y+4
 1242 0594 08DE      		rcall switch_on_led
 1243 0596 03C0      		rjmp .L62
 1244               	.L63:
 175:ledmeter.c    ****         } else {
 176:ledmeter.c    ****             switch_off_led(i);
 1246               	.LM94:
 1247 0598 8B81      		ldd r24,Y+3
 1248 059a 9C81      		ldd r25,Y+4
 1249 059c 30DE      		rcall switch_off_led
 1250               	.L62:
 1252               	.LM95:
 1253 059e 8B81      		ldd r24,Y+3
 1254 05a0 9C81      		ldd r25,Y+4
 1255 05a2 0197      		sbiw r24,1
 1256 05a4 9C83      		std Y+4,r25
 1257 05a6 8B83      		std Y+3,r24
 1258 05a8 E4CF      		rjmp .L60
 1259               	.L59:
 1260               	/* epilogue: frame size=4 */
 1261 05aa 2496      		adiw r28,4
 1262 05ac 0FB6      		in __tmp_reg__,__SREG__
 1263 05ae F894      		cli
 1264 05b0 DEBF      		out __SP_H__,r29
 1265 05b2 0FBE      		out __SREG__,__tmp_reg__
 1266 05b4 CDBF      		out __SP_L__,r28
 1267 05b6 DF91      		pop r29
 1268 05b8 CF91      		pop r28
 1269 05ba 0895      		ret
 1270               	/* epilogue end (size=9) */
 1271               	/* function switch_on_max_dels size 53 (34) */
 1276               	.Lscope10:
 1279               	.global	led_alarm
 1281               	led_alarm:
 177:ledmeter.c    ****         }
 178:ledmeter.c    ****     }
 179:ledmeter.c    ****     // TO TEST (switch off)
 180:ledmeter.c    **** }
 181:ledmeter.c    **** 
 182:ledmeter.c    **** /*
 183:ledmeter.c    ****  * switch off every leds, wait and swith them all, n times (a sort of visual alarm)
 184:ledmeter.c    ****  */
 185:ledmeter.c    **** void led_alarm(int n) {
 1283               	.LM96:
 1284               	/* prologue: frame size=16 */
 1285 05bc CF93      		push r28
 1286 05be DF93      		push r29
 1287 05c0 CDB7      		in r28,__SP_L__
 1288 05c2 DEB7      		in r29,__SP_H__
 1289 05c4 6097      		sbiw r28,16
 1290 05c6 0FB6      		in __tmp_reg__,__SREG__
 1291 05c8 F894      		cli
 1292 05ca DEBF      		out __SP_H__,r29
 1293 05cc 0FBE      		out __SREG__,__tmp_reg__
 1294 05ce CDBF      		out __SP_L__,r28
 1295               	/* prologue end (size=10) */
 1296 05d0 9A83      		std Y+2,r25
 1297 05d2 8983      		std Y+1,r24
 186:ledmeter.c    ****     int i;
 187:ledmeter.c    ****     for(i = 1; i<=n; i++) {
 1299               	.LM97:
 1300 05d4 81E0      		ldi r24,lo8(1)
 1301 05d6 90E0      		ldi r25,hi8(1)
 1302 05d8 9C83      		std Y+4,r25
 1303 05da 8B83      		std Y+3,r24
 1304               	.L66:
 1306               	.LM98:
 1307 05dc 2B81      		ldd r18,Y+3
 1308 05de 3C81      		ldd r19,Y+4
 1309 05e0 8981      		ldd r24,Y+1
 1310 05e2 9A81      		ldd r25,Y+2
 1311 05e4 8217      		cp r24,r18
 1312 05e6 9307      		cpc r25,r19
 1313 05e8 0CF4      		brge .+2
 1314 05ea 9CC0      		rjmp .L65
 188:ledmeter.c    ****         switch_off_all_leds();
 1316               	.LM99:
 1317 05ec D2DD      		rcall switch_off_all_leds
 1318               	.LBB18:
 1320               	.Ltext9:
 1322               	.LM100:
 1323 05ee 80E0      		ldi r24,lo8(0x42480000)
 1324 05f0 90E0      		ldi r25,hi8(0x42480000)
 1325 05f2 A8E4      		ldi r26,hlo8(0x42480000)
 1326 05f4 B2E4      		ldi r27,hhi8(0x42480000)
 1327 05f6 8D83      		std Y+5,r24
 1328 05f8 9E83      		std Y+6,r25
 1329 05fa AF83      		std Y+7,r26
 1330 05fc B887      		std Y+8,r27
 1331               	.LBB19:
 1333               	.LM101:
 1334 05fe 20E0      		ldi r18,lo8(0x437a0000)
 1335 0600 30E0      		ldi r19,hi8(0x437a0000)
 1336 0602 4AE7      		ldi r20,hlo8(0x437a0000)
 1337 0604 53E4      		ldi r21,hhi8(0x437a0000)
 1338 0606 6D81      		ldd r22,Y+5
 1339 0608 7E81      		ldd r23,Y+6
 1340 060a 8F81      		ldd r24,Y+7
 1341 060c 9885      		ldd r25,Y+8
 1342 060e 00D0      		rcall __mulsf3
 1343 0610 DC01      		movw r26,r24
 1344 0612 CB01      		movw r24,r22
 1345 0614 8B87      		std Y+11,r24
 1346 0616 9C87      		std Y+12,r25
 1347 0618 AD87      		std Y+13,r26
 1348 061a BE87      		std Y+14,r27
 1350               	.LM102:
 1351 061c 20E0      		ldi r18,lo8(0x3f800000)
 1352 061e 30E0      		ldi r19,hi8(0x3f800000)
 1353 0620 40E8      		ldi r20,hlo8(0x3f800000)
 1354 0622 5FE3      		ldi r21,hhi8(0x3f800000)
 1355 0624 6B85      		ldd r22,Y+11
 1356 0626 7C85      		ldd r23,Y+12
 1357 0628 8D85      		ldd r24,Y+13
 1358 062a 9E85      		ldd r25,Y+14
 1359 062c 00D0      		rcall __ltsf2
 1360 062e 8823      		tst r24
 1361 0630 0CF0      		brlt .L70
 1362 0632 05C0      		rjmp .L69
 1363               	.L70:
 1365               	.LM103:
 1366 0634 81E0      		ldi r24,lo8(1)
 1367 0636 90E0      		ldi r25,hi8(1)
 1368 0638 9A87      		std Y+10,r25
 1369 063a 8987      		std Y+9,r24
 1370 063c 18C0      		rjmp .L71
 1371               	.L69:
 1373               	.LM104:
 1374 063e 20E0      		ldi r18,lo8(0x477fff00)
 1375 0640 3FEF      		ldi r19,hi8(0x477fff00)
 1376 0642 4FE7      		ldi r20,hlo8(0x477fff00)
 1377 0644 57E4      		ldi r21,hhi8(0x477fff00)
 1378 0646 6B85      		ldd r22,Y+11
 1379 0648 7C85      		ldd r23,Y+12
 1380 064a 8D85      		ldd r24,Y+13
 1381 064c 9E85      		ldd r25,Y+14
 1382 064e 00D0      		rcall __gtsf2
 1383 0650 1816      		cp __zero_reg__,r24
 1384 0652 0CF0      		brlt .L73
 1385 0654 03C0      		rjmp .L72
 1386               	.L73:
 1388               	.LM105:
 1389 0656 1A86      		std Y+10,__zero_reg__
 1390 0658 1986      		std Y+9,__zero_reg__
 1391 065a 09C0      		rjmp .L71
 1392               	.L72:
 1394               	.LM106:
 1395 065c 6B85      		ldd r22,Y+11
 1396 065e 7C85      		ldd r23,Y+12
 1397 0660 8D85      		ldd r24,Y+13
 1398 0662 9E85      		ldd r25,Y+14
 1399 0664 00D0      		rcall __fixunssfsi
 1400 0666 DC01      		movw r26,r24
 1401 0668 CB01      		movw r24,r22
 1402 066a 9A87      		std Y+10,r25
 1403 066c 8987      		std Y+9,r24
 1404               	.L71:
 1405               	.LBB20:
 1407               	.LM107:
 1408 066e 8985      		ldd r24,Y+9
 1409 0670 9A85      		ldd r25,Y+10
 1410 0672 988B      		std Y+16,r25
 1411 0674 8F87      		std Y+15,r24
 1412               	.LBB21:
 1414               	.LM108:
 1415 0676 8F85      		ldd r24,Y+15
 1416 0678 9889      		ldd r25,Y+16
 1417               	/* #APP */
 1418 067a 0197      		1: sbiw r24,1
 1419 067c F1F7      		brne 1b
 1420               	/* #NOAPP */
 1421 067e 988B      		std Y+16,r25
 1422 0680 8F87      		std Y+15,r24
 1423               	.LBE21:
 1424               	.LBE20:
 1425               	.LBE19:
 1426               	.LBE18:
 1428               	.Ltext10:
 189:ledmeter.c    ****         _delay_ms(50);
 190:ledmeter.c    ****         switch_on_all_leds();
 1430               	.LM109:
 1431 0682 7EDD      		rcall switch_on_all_leds
 1432               	.LBB22:
 1434               	.Ltext11:
 1436               	.LM110:
 1437 0684 80E0      		ldi r24,lo8(0x42480000)
 1438 0686 90E0      		ldi r25,hi8(0x42480000)
 1439 0688 A8E4      		ldi r26,hlo8(0x42480000)
 1440 068a B2E4      		ldi r27,hhi8(0x42480000)
 1441 068c 8B87      		std Y+11,r24
 1442 068e 9C87      		std Y+12,r25
 1443 0690 AD87      		std Y+13,r26
 1444 0692 BE87      		std Y+14,r27
 1445               	.LBB23:
 1447               	.LM111:
 1448 0694 20E0      		ldi r18,lo8(0x437a0000)
 1449 0696 30E0      		ldi r19,hi8(0x437a0000)
 1450 0698 4AE7      		ldi r20,hlo8(0x437a0000)
 1451 069a 53E4      		ldi r21,hhi8(0x437a0000)
 1452 069c 6B85      		ldd r22,Y+11
 1453 069e 7C85      		ldd r23,Y+12
 1454 06a0 8D85      		ldd r24,Y+13
 1455 06a2 9E85      		ldd r25,Y+14
 1456 06a4 00D0      		rcall __mulsf3
 1457 06a6 DC01      		movw r26,r24
 1458 06a8 CB01      		movw r24,r22
 1459 06aa 8D83      		std Y+5,r24
 1460 06ac 9E83      		std Y+6,r25
 1461 06ae AF83      		std Y+7,r26
 1462 06b0 B887      		std Y+8,r27
 1464               	.LM112:
 1465 06b2 20E0      		ldi r18,lo8(0x3f800000)
 1466 06b4 30E0      		ldi r19,hi8(0x3f800000)
 1467 06b6 40E8      		ldi r20,hlo8(0x3f800000)
 1468 06b8 5FE3      		ldi r21,hhi8(0x3f800000)
 1469 06ba 6D81      		ldd r22,Y+5
 1470 06bc 7E81      		ldd r23,Y+6
 1471 06be 8F81      		ldd r24,Y+7
 1472 06c0 9885      		ldd r25,Y+8
 1473 06c2 00D0      		rcall __ltsf2
 1474 06c4 8823      		tst r24
 1475 06c6 0CF0      		brlt .L78
 1476 06c8 05C0      		rjmp .L77
 1477               	.L78:
 1479               	.LM113:
 1480 06ca 81E0      		ldi r24,lo8(1)
 1481 06cc 90E0      		ldi r25,hi8(1)
 1482 06ce 988B      		std Y+16,r25
 1483 06d0 8F87      		std Y+15,r24
 1484 06d2 18C0      		rjmp .L79
 1485               	.L77:
 1487               	.LM114:
 1488 06d4 20E0      		ldi r18,lo8(0x477fff00)
 1489 06d6 3FEF      		ldi r19,hi8(0x477fff00)
 1490 06d8 4FE7      		ldi r20,hlo8(0x477fff00)
 1491 06da 57E4      		ldi r21,hhi8(0x477fff00)
 1492 06dc 6D81      		ldd r22,Y+5
 1493 06de 7E81      		ldd r23,Y+6
 1494 06e0 8F81      		ldd r24,Y+7
 1495 06e2 9885      		ldd r25,Y+8
 1496 06e4 00D0      		rcall __gtsf2
 1497 06e6 1816      		cp __zero_reg__,r24
 1498 06e8 0CF0      		brlt .L81
 1499 06ea 03C0      		rjmp .L80
 1500               	.L81:
 1502               	.LM115:
 1503 06ec 188A      		std Y+16,__zero_reg__
 1504 06ee 1F86      		std Y+15,__zero_reg__
 1505 06f0 09C0      		rjmp .L79
 1506               	.L80:
 1508               	.LM116:
 1509 06f2 6D81      		ldd r22,Y+5
 1510 06f4 7E81      		ldd r23,Y+6
 1511 06f6 8F81      		ldd r24,Y+7
 1512 06f8 9885      		ldd r25,Y+8
 1513 06fa 00D0      		rcall __fixunssfsi
 1514 06fc DC01      		movw r26,r24
 1515 06fe CB01      		movw r24,r22
 1516 0700 988B      		std Y+16,r25
 1517 0702 8F87      		std Y+15,r24
 1518               	.L79:
 1519               	.LBB24:
 1521               	.LM117:
 1522 0704 8F85      		ldd r24,Y+15
 1523 0706 9889      		ldd r25,Y+16
 1524 0708 9A87      		std Y+10,r25
 1525 070a 8987      		std Y+9,r24
 1526               	.LBB25:
 1528               	.LM118:
 1529 070c 8985      		ldd r24,Y+9
 1530 070e 9A85      		ldd r25,Y+10
 1531               	/* #APP */
 1532 0710 0197      		1: sbiw r24,1
 1533 0712 F1F7      		brne 1b
 1534               	/* #NOAPP */
 1535 0714 9A87      		std Y+10,r25
 1536 0716 8987      		std Y+9,r24
 1537               	.LBE25:
 1538               	.LBE24:
 1539               	.LBE23:
 1540               	.LBE22:
 1542               	.Ltext12:
 1544               	.LM119:
 1545 0718 8B81      		ldd r24,Y+3
 1546 071a 9C81      		ldd r25,Y+4
 1547 071c 0196      		adiw r24,1
 1548 071e 9C83      		std Y+4,r25
 1549 0720 8B83      		std Y+3,r24
 1550 0722 5CCF      		rjmp .L66
 1551               	.L65:
 1552               	/* epilogue: frame size=16 */
 1553 0724 6096      		adiw r28,16
 1554 0726 0FB6      		in __tmp_reg__,__SREG__
 1555 0728 F894      		cli
 1556 072a DEBF      		out __SP_H__,r29
 1557 072c 0FBE      		out __SREG__,__tmp_reg__
 1558 072e CDBF      		out __SP_L__,r28
 1559 0730 DF91      		pop r29
 1560 0732 CF91      		pop r28
 1561 0734 0895      		ret
 1562               	/* epilogue end (size=9) */
 1563               	/* function led_alarm size 193 (174) */
 1588               	.Lscope11:
 1591               	.global	show_percent
 1593               	show_percent:
 191:ledmeter.c    ****         _delay_ms(50);
 192:ledmeter.c    ****     }
 193:ledmeter.c    **** }
 194:ledmeter.c    **** 
 195:ledmeter.c    **** /*
 196:ledmeter.c    ****  * switch on every dels depending of the percentage p
 197:ledmeter.c    ****  */
 198:ledmeter.c    **** #define round floor
 199:ledmeter.c    **** void show_percent(double p) {
 1595               	.LM120:
 1596               	/* prologue: frame size=6 */
 1597 0736 CF93      		push r28
 1598 0738 DF93      		push r29
 1599 073a CDB7      		in r28,__SP_L__
 1600 073c DEB7      		in r29,__SP_H__
 1601 073e 2697      		sbiw r28,6
 1602 0740 0FB6      		in __tmp_reg__,__SREG__
 1603 0742 F894      		cli
 1604 0744 DEBF      		out __SP_H__,r29
 1605 0746 0FBE      		out __SREG__,__tmp_reg__
 1606 0748 CDBF      		out __SP_L__,r28
 1607               	/* prologue end (size=10) */
 1608 074a 6983      		std Y+1,r22
 1609 074c 7A83      		std Y+2,r23
 1610 074e 8B83      		std Y+3,r24
 1611 0750 9C83      		std Y+4,r25
 200:ledmeter.c    ****     // p pourcent
 201:ledmeter.c    ****     int n;
 202:ledmeter.c    ****     //n = 4;
 203:ledmeter.c    ****     n = round(p / 100.0 * (Nleds+0.5)); // TO FIX (math.h ceil floor ... round en Java !)
 1613               	.LM121:
 1614 0752 20E0      		ldi r18,lo8(0x42c80000)
 1615 0754 30E0      		ldi r19,hi8(0x42c80000)
 1616 0756 48EC      		ldi r20,hlo8(0x42c80000)
 1617 0758 52E4      		ldi r21,hhi8(0x42c80000)
 1618 075a 6981      		ldd r22,Y+1
 1619 075c 7A81      		ldd r23,Y+2
 1620 075e 8B81      		ldd r24,Y+3
 1621 0760 9C81      		ldd r25,Y+4
 1622 0762 00D0      		rcall __divsf3
 1623 0764 DC01      		movw r26,r24
 1624 0766 CB01      		movw r24,r22
 1625 0768 20E0      		ldi r18,lo8(0x41080000)
 1626 076a 30E0      		ldi r19,hi8(0x41080000)
 1627 076c 48E0      		ldi r20,hlo8(0x41080000)
 1628 076e 51E4      		ldi r21,hhi8(0x41080000)
 1629 0770 BC01      		movw r22,r24
 1630 0772 CD01      		movw r24,r26
 1631 0774 00D0      		rcall __mulsf3
 1632 0776 DC01      		movw r26,r24
 1633 0778 CB01      		movw r24,r22
 1634 077a BC01      		movw r22,r24
 1635 077c CD01      		movw r24,r26
 1636 077e 00D0      		rcall floor
 1637 0780 DC01      		movw r26,r24
 1638 0782 CB01      		movw r24,r22
 1639 0784 BC01      		movw r22,r24
 1640 0786 CD01      		movw r24,r26
 1641 0788 00D0      		rcall __fixsfsi
 1642 078a DC01      		movw r26,r24
 1643 078c CB01      		movw r24,r22
 1644 078e 9E83      		std Y+6,r25
 1645 0790 8D83      		std Y+5,r24
 204:ledmeter.c    ****     // TO FIX : +0.5 is a very dirty hack
 205:ledmeter.c    ****     switch_on_min_dels(n);
 1647               	.LM122:
 1648 0792 8D81      		ldd r24,Y+5
 1649 0794 9E81      		ldd r25,Y+6
 1650 0796 ABDE      		rcall switch_on_min_dels
 1651               	/* epilogue: frame size=6 */
 1652 0798 2696      		adiw r28,6
 1653 079a 0FB6      		in __tmp_reg__,__SREG__
 1654 079c F894      		cli
 1655 079e DEBF      		out __SP_H__,r29
 1656 07a0 0FBE      		out __SREG__,__tmp_reg__
 1657 07a2 CDBF      		out __SP_L__,r28
 1658 07a4 DF91      		pop r29
 1659 07a6 CF91      		pop r28
 1660 07a8 0895      		ret
 1661               	/* epilogue end (size=9) */
 1662               	/* function show_percent size 58 (39) */
 1667               	.Lscope12:
 1669               	.global	StartStopChronometer
 1671               	StartStopChronometer:
 206:ledmeter.c    **** }
 207:ledmeter.c    **** 
 208:ledmeter.c    **** 
 209:ledmeter.c    **** /*
 210:ledmeter.c    ****  * start or stop chronometer
 211:ledmeter.c    ****  */
 212:ledmeter.c    **** void StartStopChronometer() {
 1673               	.LM123:
 1674               	/* prologue: frame size=0 */
 1675 07aa CF93      		push r28
 1676 07ac DF93      		push r29
 1677 07ae CDB7      		in r28,__SP_L__
 1678 07b0 DEB7      		in r29,__SP_H__
 1679               	/* prologue end (size=4) */
 213:ledmeter.c    ****     led_alarm(3);
 1681               	.LM124:
 1682 07b2 83E0      		ldi r24,lo8(3)
 1683 07b4 90E0      		ldi r25,hi8(3)
 1684 07b6 02DF      		rcall led_alarm
 214:ledmeter.c    ****     if (running_chronometer) {
 1686               	.LM125:
 1687 07b8 8091 0000 		lds r24,running_chronometer
 1688 07bc 9091 0000 		lds r25,(running_chronometer)+1
 1689 07c0 0097      		sbiw r24,0
 1690 07c2 29F0      		breq .L87
 215:ledmeter.c    ****        running_chronometer = 0; // false
 1692               	.LM126:
 1693 07c4 1092 0000 		sts (running_chronometer)+1,__zero_reg__
 1694 07c8 1092 0000 		sts running_chronometer,__zero_reg__
 1695 07cc 06C0      		rjmp .L86
 1696               	.L87:
 216:ledmeter.c    ****     } else {
 217:ledmeter.c    ****        running_chronometer = -1; // true
 1698               	.LM127:
 1699 07ce 8FEF      		ldi r24,lo8(-1)
 1700 07d0 9FEF      		ldi r25,hi8(-1)
 1701 07d2 9093 0000 		sts (running_chronometer)+1,r25
 1702 07d6 8093 0000 		sts running_chronometer,r24
 1703               	.L86:
 1704               	/* epilogue: frame size=0 */
 1705 07da DF91      		pop r29
 1706 07dc CF91      		pop r28
 1707 07de 0895      		ret
 1708               	/* epilogue end (size=3) */
 1709               	/* function StartStopChronometer size 27 (20) */
 1711               	.Lscope13:
 1713               	.global	TestRunningChronometer
 1715               	TestRunningChronometer:
 218:ledmeter.c    ****     }
 219:ledmeter.c    **** }
 220:ledmeter.c    **** 
 221:ledmeter.c    **** void TestRunningChronometer() {
 1717               	.LM128:
 1718               	/* prologue: frame size=12 */
 1719 07e0 CF93      		push r28
 1720 07e2 DF93      		push r29
 1721 07e4 CDB7      		in r28,__SP_L__
 1722 07e6 DEB7      		in r29,__SP_H__
 1723 07e8 2C97      		sbiw r28,12
 1724 07ea 0FB6      		in __tmp_reg__,__SREG__
 1725 07ec F894      		cli
 1726 07ee DEBF      		out __SP_H__,r29
 1727 07f0 0FBE      		out __SREG__,__tmp_reg__
 1728 07f2 CDBF      		out __SP_L__,r28
 1729               	/* prologue end (size=10) */
 222:ledmeter.c    ****     if (running_chronometer) {
 1731               	.LM129:
 1732 07f4 8091 0000 		lds r24,running_chronometer
 1733 07f8 9091 0000 		lds r25,(running_chronometer)+1
 1734 07fc 0097      		sbiw r24,0
 1735 07fe 09F4      		brne .+2
 1736 0800 9AC0      		rjmp .L89
 223:ledmeter.c    ****         switch_on_led(8);
 1738               	.LM130:
 1739 0802 88E0      		ldi r24,lo8(8)
 1740 0804 90E0      		ldi r25,hi8(8)
 1741 0806 CFDC      		rcall switch_on_led
 1742               	.LBB26:
 1744               	.Ltext13:
 1746               	.LM131:
 1747 0808 80E0      		ldi r24,lo8(0x42c80000)
 1748 080a 90E0      		ldi r25,hi8(0x42c80000)
 1749 080c A8EC      		ldi r26,hlo8(0x42c80000)
 1750 080e B2E4      		ldi r27,hhi8(0x42c80000)
 1751 0810 8983      		std Y+1,r24
 1752 0812 9A83      		std Y+2,r25
 1753 0814 AB83      		std Y+3,r26
 1754 0816 BC83      		std Y+4,r27
 1755               	.LBB27:
 1757               	.LM132:
 1758 0818 20E0      		ldi r18,lo8(0x437a0000)
 1759 081a 30E0      		ldi r19,hi8(0x437a0000)
 1760 081c 4AE7      		ldi r20,hlo8(0x437a0000)
 1761 081e 53E4      		ldi r21,hhi8(0x437a0000)
 1762 0820 6981      		ldd r22,Y+1
 1763 0822 7A81      		ldd r23,Y+2
 1764 0824 8B81      		ldd r24,Y+3
 1765 0826 9C81      		ldd r25,Y+4
 1766 0828 00D0      		rcall __mulsf3
 1767 082a DC01      		movw r26,r24
 1768 082c CB01      		movw r24,r22
 1769 082e 8F83      		std Y+7,r24
 1770 0830 9887      		std Y+8,r25
 1771 0832 A987      		std Y+9,r26
 1772 0834 BA87      		std Y+10,r27
 1774               	.LM133:
 1775 0836 20E0      		ldi r18,lo8(0x3f800000)
 1776 0838 30E0      		ldi r19,hi8(0x3f800000)
 1777 083a 40E8      		ldi r20,hlo8(0x3f800000)
 1778 083c 5FE3      		ldi r21,hhi8(0x3f800000)
 1779 083e 6F81      		ldd r22,Y+7
 1780 0840 7885      		ldd r23,Y+8
 1781 0842 8985      		ldd r24,Y+9
 1782 0844 9A85      		ldd r25,Y+10
 1783 0846 00D0      		rcall __ltsf2
 1784 0848 8823      		tst r24
 1785 084a 0CF0      		brlt .L92
 1786 084c 05C0      		rjmp .L91
 1787               	.L92:
 1789               	.LM134:
 1790 084e 81E0      		ldi r24,lo8(1)
 1791 0850 90E0      		ldi r25,hi8(1)
 1792 0852 9E83      		std Y+6,r25
 1793 0854 8D83      		std Y+5,r24
 1794 0856 18C0      		rjmp .L93
 1795               	.L91:
 1797               	.LM135:
 1798 0858 20E0      		ldi r18,lo8(0x477fff00)
 1799 085a 3FEF      		ldi r19,hi8(0x477fff00)
 1800 085c 4FE7      		ldi r20,hlo8(0x477fff00)
 1801 085e 57E4      		ldi r21,hhi8(0x477fff00)
 1802 0860 6F81      		ldd r22,Y+7
 1803 0862 7885      		ldd r23,Y+8
 1804 0864 8985      		ldd r24,Y+9
 1805 0866 9A85      		ldd r25,Y+10
 1806 0868 00D0      		rcall __gtsf2
 1807 086a 1816      		cp __zero_reg__,r24
 1808 086c 0CF0      		brlt .L95
 1809 086e 03C0      		rjmp .L94
 1810               	.L95:
 1812               	.LM136:
 1813 0870 1E82      		std Y+6,__zero_reg__
 1814 0872 1D82      		std Y+5,__zero_reg__
 1815 0874 09C0      		rjmp .L93
 1816               	.L94:
 1818               	.LM137:
 1819 0876 6F81      		ldd r22,Y+7
 1820 0878 7885      		ldd r23,Y+8
 1821 087a 8985      		ldd r24,Y+9
 1822 087c 9A85      		ldd r25,Y+10
 1823 087e 00D0      		rcall __fixunssfsi
 1824 0880 DC01      		movw r26,r24
 1825 0882 CB01      		movw r24,r22
 1826 0884 9E83      		std Y+6,r25
 1827 0886 8D83      		std Y+5,r24
 1828               	.L93:
 1829               	.LBB28:
 1831               	.LM138:
 1832 0888 8D81      		ldd r24,Y+5
 1833 088a 9E81      		ldd r25,Y+6
 1834 088c 9C87      		std Y+12,r25
 1835 088e 8B87      		std Y+11,r24
 1836               	.LBB29:
 1838               	.LM139:
 1839 0890 8B85      		ldd r24,Y+11
 1840 0892 9C85      		ldd r25,Y+12
 1841               	/* #APP */
 1842 0894 0197      		1: sbiw r24,1
 1843 0896 F1F7      		brne 1b
 1844               	/* #NOAPP */
 1845 0898 9C87      		std Y+12,r25
 1846 089a 8B87      		std Y+11,r24
 1847               	.LBE29:
 1848               	.LBE28:
 1849               	.LBE27:
 1850               	.LBE26:
 1852               	.Ltext14:
 224:ledmeter.c    ****         _delay_ms(100);
 225:ledmeter.c    ****         switch_off_led(8);
 1854               	.LM140:
 1855 089c 88E0      		ldi r24,lo8(8)
 1856 089e 90E0      		ldi r25,hi8(8)
 1857 08a0 AEDC      		rcall switch_off_led
 1858               	.LBB30:
 1860               	.Ltext15:
 1862               	.LM141:
 1863 08a2 80E0      		ldi r24,lo8(0x42c80000)
 1864 08a4 90E0      		ldi r25,hi8(0x42c80000)
 1865 08a6 A8EC      		ldi r26,hlo8(0x42c80000)
 1866 08a8 B2E4      		ldi r27,hhi8(0x42c80000)
 1867 08aa 8F83      		std Y+7,r24
 1868 08ac 9887      		std Y+8,r25
 1869 08ae A987      		std Y+9,r26
 1870 08b0 BA87      		std Y+10,r27
 1871               	.LBB31:
 1873               	.LM142:
 1874 08b2 20E0      		ldi r18,lo8(0x437a0000)
 1875 08b4 30E0      		ldi r19,hi8(0x437a0000)
 1876 08b6 4AE7      		ldi r20,hlo8(0x437a0000)
 1877 08b8 53E4      		ldi r21,hhi8(0x437a0000)
 1878 08ba 6F81      		ldd r22,Y+7
 1879 08bc 7885      		ldd r23,Y+8
 1880 08be 8985      		ldd r24,Y+9
 1881 08c0 9A85      		ldd r25,Y+10
 1882 08c2 00D0      		rcall __mulsf3
 1883 08c4 DC01      		movw r26,r24
 1884 08c6 CB01      		movw r24,r22
 1885 08c8 8983      		std Y+1,r24
 1886 08ca 9A83      		std Y+2,r25
 1887 08cc AB83      		std Y+3,r26
 1888 08ce BC83      		std Y+4,r27
 1890               	.LM143:
 1891 08d0 20E0      		ldi r18,lo8(0x3f800000)
 1892 08d2 30E0      		ldi r19,hi8(0x3f800000)
 1893 08d4 40E8      		ldi r20,hlo8(0x3f800000)
 1894 08d6 5FE3      		ldi r21,hhi8(0x3f800000)
 1895 08d8 6981      		ldd r22,Y+1
 1896 08da 7A81      		ldd r23,Y+2
 1897 08dc 8B81      		ldd r24,Y+3
 1898 08de 9C81      		ldd r25,Y+4
 1899 08e0 00D0      		rcall __ltsf2
 1900 08e2 8823      		tst r24
 1901 08e4 0CF0      		brlt .L100
 1902 08e6 05C0      		rjmp .L99
 1903               	.L100:
 1905               	.LM144:
 1906 08e8 81E0      		ldi r24,lo8(1)
 1907 08ea 90E0      		ldi r25,hi8(1)
 1908 08ec 9C87      		std Y+12,r25
 1909 08ee 8B87      		std Y+11,r24
 1910 08f0 18C0      		rjmp .L101
 1911               	.L99:
 1913               	.LM145:
 1914 08f2 20E0      		ldi r18,lo8(0x477fff00)
 1915 08f4 3FEF      		ldi r19,hi8(0x477fff00)
 1916 08f6 4FE7      		ldi r20,hlo8(0x477fff00)
 1917 08f8 57E4      		ldi r21,hhi8(0x477fff00)
 1918 08fa 6981      		ldd r22,Y+1
 1919 08fc 7A81      		ldd r23,Y+2
 1920 08fe 8B81      		ldd r24,Y+3
 1921 0900 9C81      		ldd r25,Y+4
 1922 0902 00D0      		rcall __gtsf2
 1923 0904 1816      		cp __zero_reg__,r24
 1924 0906 0CF0      		brlt .L103
 1925 0908 03C0      		rjmp .L102
 1926               	.L103:
 1928               	.LM146:
 1929 090a 1C86      		std Y+12,__zero_reg__
 1930 090c 1B86      		std Y+11,__zero_reg__
 1931 090e 09C0      		rjmp .L101
 1932               	.L102:
 1934               	.LM147:
 1935 0910 6981      		ldd r22,Y+1
 1936 0912 7A81      		ldd r23,Y+2
 1937 0914 8B81      		ldd r24,Y+3
 1938 0916 9C81      		ldd r25,Y+4
 1939 0918 00D0      		rcall __fixunssfsi
 1940 091a DC01      		movw r26,r24
 1941 091c CB01      		movw r24,r22
 1942 091e 9C87      		std Y+12,r25
 1943 0920 8B87      		std Y+11,r24
 1944               	.L101:
 1945               	.LBB32:
 1947               	.LM148:
 1948 0922 8B85      		ldd r24,Y+11
 1949 0924 9C85      		ldd r25,Y+12
 1950 0926 9E83      		std Y+6,r25
 1951 0928 8D83      		std Y+5,r24
 1952               	.LBB33:
 1954               	.LM149:
 1955 092a 8D81      		ldd r24,Y+5
 1956 092c 9E81      		ldd r25,Y+6
 1957               	/* #APP */
 1958 092e 0197      		1: sbiw r24,1
 1959 0930 F1F7      		brne 1b
 1960               	/* #NOAPP */
 1961 0932 9E83      		std Y+6,r25
 1962 0934 8D83      		std Y+5,r24
 1963               	.L89:
 1964               	.LBE33:
 1965               	.LBE32:
 1966               	.LBE31:
 1967               	.LBE30:
 1968               	/* epilogue: frame size=12 */
 1969 0936 2C96      		adiw r28,12
 1970 0938 0FB6      		in __tmp_reg__,__SREG__
 1971 093a F894      		cli
 1972 093c DEBF      		out __SP_H__,r29
 1973 093e 0FBE      		out __SREG__,__tmp_reg__
 1974 0940 CDBF      		out __SP_L__,r28
 1975 0942 DF91      		pop r29
 1976 0944 CF91      		pop r28
 1977 0946 0895      		ret
 1978               	/* epilogue end (size=9) */
 1979               	/* function TestRunningChronometer size 184 (165) */
 2001               	.Lscope14:
 2002               		.lcomm analog_result.0,2
 2003               		.lcomm analog_busy.1,1
 2005               	.global	init
 2007               	init:
 2009               	.Ltext16:
 226:ledmeter.c    ****         _delay_ms(100);
 227:ledmeter.c    ****     }
 228:ledmeter.c    **** }
 229:ledmeter.c    **** 
 230:ledmeter.c    **** 
 231:ledmeter.c    **** /*
 232:ledmeter.c    ****  *  init function
 233:ledmeter.c    ****  */
 234:ledmeter.c    **** void init() {
 2011               	.LM150:
 2012               	/* prologue: frame size=0 */
 2013 0948 CF93      		push r28
 2014 094a DF93      		push r29
 2015 094c CDB7      		in r28,__SP_L__
 2016 094e DEB7      		in r29,__SP_H__
 2017               	/* prologue end (size=4) */
 235:ledmeter.c    ****    // ********
 236:ledmeter.c    ****    // * Dels *
 237:ledmeter.c    ****    // ********
 238:ledmeter.c    ****    DDRC=0xFF; // set up PORTD pins 0 to 7 as output
 2019               	.LM151:
 2020 0950 8FEF      		ldi r24,lo8(-1)
 2021 0952 8093 3400 		sts 52,r24
 239:ledmeter.c    ****    //switch_on_all_leds();
 240:ledmeter.c    ****    switch_off_all_leds();
 2023               	.LM152:
 2024 0956 1DDC      		rcall switch_off_all_leds
 241:ledmeter.c    **** 
 242:ledmeter.c    ****    // *********************************
 243:ledmeter.c    ****    // * Start/Stop chronometer (INT0) *
 244:ledmeter.c    ****    // *********************************
 245:ledmeter.c    ****    // Set Pin 6 (PD2) as the pin to use for this example
 246:ledmeter.c    ****    //PCMSK |= (1<<PIND2); // TO FIX
 247:ledmeter.c    ****    //PIND |= (1<<PIND2); // try scls:Error : read-only !!!
 248:ledmeter.c    **** 
 249:ledmeter.c    ****    // interrupt on INT0 pin falling edge (sensor triggered)
 250:ledmeter.c    ****    MCUCR = (1<<ISC01) | (1<<ISC00);
 2026               	.LM153:
 2027 0958 83E0      		ldi r24,lo8(3)
 2028 095a 8093 5500 		sts 85,r24
 251:ledmeter.c    **** 
 252:ledmeter.c    ****    // turn on interrupts!
 253:ledmeter.c    ****    //GIMSK  |= (1<<INT0); // TO FIX
 254:ledmeter.c    **** 
 255:ledmeter.c    ****    GICR |= (1<<INT0); //INT0
 2030               	.LM154:
 2031 095e 8091 5B00 		lds r24,91
 2032 0962 8064      		ori r24,lo8(64)
 2033 0964 8093 5B00 		sts 91,r24
 256:ledmeter.c    **** 
 257:ledmeter.c    ****    sei(); // enable interrupts
 2035               	.LM155:
 2036               	/* #APP */
 2037 0968 7894      		sei
 258:ledmeter.c    **** 
 259:ledmeter.c    ****    // *************************************************
 260:ledmeter.c    ****    // * Conv Analog to Digital (CAN for RPM and Temp) *
 261:ledmeter.c    ****    // *************************************************
 262:ledmeter.c    **** 
 263:ledmeter.c    ****    volatile static int analog_result;
 264:ledmeter.c    ****    volatile static unsigned char analog_busy;
 265:ledmeter.c    **** 
 266:ledmeter.c    ****    analog_busy=1; // busy mark the ADC function
 2039               	.LM156:
 2040               	/* #NOAPP */
 2041 096a 81E0      		ldi r24,lo8(1)
 2042 096c 8093 0000 		sts analog_busy.1,r24
 267:ledmeter.c    ****    channel=0; // measure ADC0
 2044               	.LM157:
 2045 0970 1092 0000 		sts (channel)+1,__zero_reg__
 2046 0974 1092 0000 		sts channel,__zero_reg__
 268:ledmeter.c    ****    // use internal 2.56V ref
 269:ledmeter.c    ****    //outb((1<<REFS1)|(1<<REFS0)|(channel & 0x07),ADMUX);
 270:ledmeter.c    ****    ADMUX=(1<<REFS1)|(1<<REFS0)|(channel & 0x07);
 2048               	.LM158:
 2049 0978 8091 0000 		lds r24,channel
 2050 097c 982F      		mov r25,r24
 2051 097e 9770      		andi r25,lo8(7)
 2052 0980 80EC      		ldi r24,lo8(-64)
 2053 0982 892B      		or r24,r25
 2054 0984 8093 2700 		sts 39,r24
 271:ledmeter.c    ****    //outb((1<<ADEN)|(1<<ADIE)|(1<<ADIF)|(1<<ADPS2),ADCSRA);
 272:ledmeter.c    ****    ADCSRA=(1<<ADEN)|(1<<ADIE)|(1<<ADIF)|(1<<ADPS2);
 2056               	.LM159:
 2057 0988 8CE9      		ldi r24,lo8(-100)
 2058 098a 8093 2600 		sts 38,r24
 273:ledmeter.c    ****    //sbi(ADCSRA,ADSC); // start conversion
 274:ledmeter.c    ****    (ADCSRA) |= (1 << (ADSC));
 2060               	.LM160:
 2061 098e 8091 2600 		lds r24,38
 2062 0992 8064      		ori r24,lo8(64)
 2063 0994 8093 2600 		sts 38,r24
 275:ledmeter.c    **** 
 276:ledmeter.c    **** 
 277:ledmeter.c    ****    /*
 278:ledmeter.c    **** 	ADCSRA |= (_BV(ADEN));   // enable ADC (turn on ADC power)
 279:ledmeter.c    **** 	ADCSRA &= ~(_BV(ADATE)); // default to single sample convert mode
 280:ledmeter.c    **** 
 281:ledmeter.c    ****    //  set default prescaler 0x06 -> CPU clk/64      a2dSetPrescaler(0x06)
 282:ledmeter.c    ****    ADCSRA = (((ADCSRA) & ~0x07) | 0x06); // ADC_PRESCALE_MASK 0x07
 283:ledmeter.c    **** 	
 284:ledmeter.c    ****    //	a2dSetReference(0x01);	// set default reference ADC_REFERENCE=0x01  ADC_REFERENCE_MASK=
 285:ledmeter.c    ****    ADMUX = (((ADMUX) & ~0xC0) | (0x01<<6));
 286:ledmeter.c    **** 	
 287:ledmeter.c    **** 	ADMUX &= ~(_BV(ADLAR));  // set to right-adjusted result
 288:ledmeter.c    ****    ADCSRA |= (_BV(ADIE));   // enable ADC interrupts
 289:ledmeter.c    **** 
 290:ledmeter.c    **** 	a2dCompleteFlag = 0;		// clear conversion complete flag (FALSE=0 TRUE=-1)
 291:ledmeter.c    **** 
 292:ledmeter.c    **** 	__asm__ __volatile__ ("sei" ::);
 293:ledmeter.c    **** 
 294:ledmeter.c    **** 	
 295:ledmeter.c    **** 	// configure a2d port (PORTA) as input
 296:ledmeter.c    **** 	// so we can receive analog signals
 297:ledmeter.c    ****    DDRA=0x00;
 298:ledmeter.c    **** 	// make sure pull-up resistors are turned off
 299:ledmeter.c    **** 	PORTA = 0x00;
 300:ledmeter.c    **** 	*/
 301:ledmeter.c    **** 
 302:ledmeter.c    ****    // **********
 303:ledmeter.c    ****    // * Keypad *
 304:ledmeter.c    ****    // **********
 305:ledmeter.c    ****    // 1 joystick button (4 directions, up, down, left, right)
 306:ledmeter.c    ****    // 2 push buttons (ok, cancel)
 307:ledmeter.c    ****    //DDRB=0x00;
 308:ledmeter.c    ****    //PORTB=0xFF;
 309:ledmeter.c    **** 
 310:ledmeter.c    ****    // ***************
 311:ledmeter.c    ****    // * Graphic LCD *
 312:ledmeter.c    ****    // ***************
 313:ledmeter.c    **** 
 314:ledmeter.c    ****    // Time
 315:ledmeter.c    ****    init_time(current_time);
 2065               	.LM161:
 2066 0998 2091 0000 		lds r18,current_time
 2067 099c 3091 0000 		lds r19,current_time+1
 2068 09a0 4091 0000 		lds r20,current_time+2
 2069 09a4 5091 0000 		lds r21,current_time+3
 2070 09a8 6091 0000 		lds r22,current_time+4
 2071 09ac 7091 0000 		lds r23,current_time+5
 2072 09b0 8091 0000 		lds r24,current_time+6
 2073 09b4 9091 0000 		lds r25,current_time+7
 2074 09b8 23DB      		rcall init_time
 316:ledmeter.c    ****    init_time(last_time);
 2076               	.LM162:
 2077 09ba 2091 0000 		lds r18,last_time
 2078 09be 3091 0000 		lds r19,last_time+1
 2079 09c2 4091 0000 		lds r20,last_time+2
 2080 09c6 5091 0000 		lds r21,last_time+3
 2081 09ca 6091 0000 		lds r22,last_time+4
 2082 09ce 7091 0000 		lds r23,last_time+5
 2083 09d2 8091 0000 		lds r24,last_time+6
 2084 09d6 9091 0000 		lds r25,last_time+7
 2085 09da 12DB      		rcall init_time
 317:ledmeter.c    ****    init_time(best_time);
 2087               	.LM163:
 2088 09dc 2091 0000 		lds r18,best_time
 2089 09e0 3091 0000 		lds r19,best_time+1
 2090 09e4 4091 0000 		lds r20,best_time+2
 2091 09e8 5091 0000 		lds r21,best_time+3
 2092 09ec 6091 0000 		lds r22,best_time+4
 2093 09f0 7091 0000 		lds r23,best_time+5
 2094 09f4 8091 0000 		lds r24,best_time+6
 2095 09f8 9091 0000 		lds r25,best_time+7
 2096 09fc 01DB      		rcall init_time
 2097               	/* epilogue: frame size=0 */
 2098 09fe DF91      		pop r29
 2099 0a00 CF91      		pop r28
 2100 0a02 0895      		ret
 2101               	/* epilogue end (size=3) */
 2102               	/* function init size 95 (88) */
 2108               	.Lscope15:
 2111               	.global	adcConvert10bit
 2113               	adcConvert10bit:
 318:ledmeter.c    **** 
 319:ledmeter.c    **** }
 320:ledmeter.c    **** 
 321:ledmeter.c    **** /*
 322:ledmeter.c    ****  * convert from analog to digital (10 bits)
 323:ledmeter.c    ****  */
 324:ledmeter.c    **** unsigned short adcConvert10bit(unsigned char ch)
 325:ledmeter.c    **** {
 2115               	.LM164:
 2116               	/* prologue: frame size=1 */
 2117 0a04 CF93      		push r28
 2118 0a06 DF93      		push r29
 2119 0a08 CDB7      		in r28,__SP_L__
 2120 0a0a DEB7      		in r29,__SP_H__
 2121 0a0c 2197      		sbiw r28,1
 2122 0a0e 0FB6      		in __tmp_reg__,__SREG__
 2123 0a10 F894      		cli
 2124 0a12 DEBF      		out __SP_H__,r29
 2125 0a14 0FBE      		out __SREG__,__tmp_reg__
 2126 0a16 CDBF      		out __SP_L__,r28
 2127               	/* prologue end (size=10) */
 2128 0a18 8983      		std Y+1,r24
 326:ledmeter.c    **** 	a2dCompleteFlag = 0;				// clear conversion complete flag
 2130               	.LM165:
 2131 0a1a 1092 0000 		sts a2dCompleteFlag,__zero_reg__
 327:ledmeter.c    **** 	ADMUX = ((ADMUX) & ~0x1F) | (ch & 0x1F);	// set channel ADC_MUX_MASK=0x1F
 2133               	.LM166:
 2134 0a1e 8091 2700 		lds r24,39
 2135 0a22 982F      		mov r25,r24
 2136 0a24 907E      		andi r25,lo8(-32)
 2137 0a26 8981      		ldd r24,Y+1
 2138 0a28 8F71      		andi r24,lo8(31)
 2139 0a2a 892B      		or r24,r25
 2140 0a2c 8093 2700 		sts 39,r24
 328:ledmeter.c    **** 	ADCSRA |= (_BV(ADIF)); // clear hardware "conversion complete" flag
 2142               	.LM167:
 2143 0a30 8091 2600 		lds r24,38
 2144 0a34 8061      		ori r24,lo8(16)
 2145 0a36 8093 2600 		sts 38,r24
 329:ledmeter.c    **** 	ADCSRA |= (_BV(ADSC)); // start conversion
 2147               	.LM168:
 2148 0a3a 8091 2600 		lds r24,38
 2149 0a3e 8064      		ori r24,lo8(64)
 2150 0a40 8093 2600 		sts 38,r24
 2151               	.L109:
 330:ledmeter.c    **** 							
 331:ledmeter.c    **** 	//while(!a2dCompleteFlag);				// wait until conversion complete
 332:ledmeter.c    **** 	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
 333:ledmeter.c    **** 	while( bit_is_set(ADCSRA, ADSC) );		// wait until conversion complete
 2153               	.LM169:
 2154 0a44 8091 2600 		lds r24,38
 2155 0a48 9927      		clr r25
 2156 0a4a 8074      		andi r24,lo8(64)
 2157 0a4c 9070      		andi r25,hi8(64)
 2158 0a4e 0097      		sbiw r24,0
 2159 0a50 09F0      		breq .L110
 2160 0a52 F8CF      		rjmp .L109
 2161               	.L110:
 334:ledmeter.c    **** 
 335:ledmeter.c    **** 	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
 336:ledmeter.c    **** 	return ((ADCL) | ((ADCH)<<8));	// read ADC (full 10 bits);
 2163               	.LM170:
 2164 0a54 8091 2400 		lds r24,36
 2165 0a58 282F      		mov r18,r24
 2166 0a5a 3327      		clr r19
 2167 0a5c 8091 2500 		lds r24,37
 2168 0a60 9927      		clr r25
 2169 0a62 982F      		mov r25,r24
 2170 0a64 8827      		clr r24
 2171 0a66 282B      		or r18,r24
 2172 0a68 392B      		or r19,r25
 2173 0a6a C901      		movw r24,r18
 2174               	/* epilogue: frame size=1 */
 2175 0a6c 2196      		adiw r28,1
 2176 0a6e 0FB6      		in __tmp_reg__,__SREG__
 2177 0a70 F894      		cli
 2178 0a72 DEBF      		out __SP_H__,r29
 2179 0a74 0FBE      		out __SREG__,__tmp_reg__
 2180 0a76 CDBF      		out __SP_L__,r28
 2181 0a78 DF91      		pop r29
 2182 0a7a CF91      		pop r28
 2183 0a7c 0895      		ret
 2184               	/* epilogue end (size=9) */
 2185               	/* function adcConvert10bit size 61 (42) */
 2187               	.Lscope16:
 2190               	.global	adcConvert8bit
 2192               	adcConvert8bit:
 337:ledmeter.c    **** }
 338:ledmeter.c    **** 
 339:ledmeter.c    **** /*
 340:ledmeter.c    ****  * convert from analog to digital (8 bits)
 341:ledmeter.c    ****  * starts conversion, waits until conversion is done, and returns result
 342:ledmeter.c    ****  */
 343:ledmeter.c    **** unsigned char adcConvert8bit(unsigned char ch)
 344:ledmeter.c    **** {
 2194               	.LM171:
 2195               	/* prologue: frame size=1 */
 2196 0a7e CF93      		push r28
 2197 0a80 DF93      		push r29
 2198 0a82 CDB7      		in r28,__SP_L__
 2199 0a84 DEB7      		in r29,__SP_H__
 2200 0a86 2197      		sbiw r28,1
 2201 0a88 0FB6      		in __tmp_reg__,__SREG__
 2202 0a8a F894      		cli
 2203 0a8c DEBF      		out __SP_H__,r29
 2204 0a8e 0FBE      		out __SREG__,__tmp_reg__
 2205 0a90 CDBF      		out __SP_L__,r28
 2206               	/* prologue end (size=10) */
 2207 0a92 8983      		std Y+1,r24
 345:ledmeter.c    **** 	// do 10-bit conversion and return highest 8 bits
 346:ledmeter.c    **** 	return adcConvert10bit(ch)>>2;			// return ADC MSB byte
 2209               	.LM172:
 2210 0a94 8981      		ldd r24,Y+1
 2211 0a96 B6DF      		rcall adcConvert10bit
 2212 0a98 9695      		lsr r25
 2213 0a9a 8795      		ror r24
 2214 0a9c 9695      		lsr r25
 2215 0a9e 8795      		ror r24
 2216 0aa0 9927      		clr r25
 2217               	/* epilogue: frame size=1 */
 2218 0aa2 2196      		adiw r28,1
 2219 0aa4 0FB6      		in __tmp_reg__,__SREG__
 2220 0aa6 F894      		cli
 2221 0aa8 DEBF      		out __SP_H__,r29
 2222 0aaa 0FBE      		out __SREG__,__tmp_reg__
 2223 0aac CDBF      		out __SP_L__,r28
 2224 0aae DF91      		pop r29
 2225 0ab0 CF91      		pop r28
 2226 0ab2 0895      		ret
 2227               	/* epilogue end (size=9) */
 2228               	/* function adcConvert8bit size 27 (8) */
 2230               	.Lscope17:
 2232               	.global	loop
 2234               	loop:
 347:ledmeter.c    **** }
 348:ledmeter.c    **** 
 349:ledmeter.c    **** /*
 350:ledmeter.c    ****  *  this is the main loop
 351:ledmeter.c    ****  */
 352:ledmeter.c    **** void loop(void) {
 2236               	.LM173:
 2237               	/* prologue: frame size=0 */
 2238 0ab4 CF93      		push r28
 2239 0ab6 DF93      		push r29
 2240 0ab8 CDB7      		in r28,__SP_L__
 2241 0aba DEB7      		in r29,__SP_H__
 2242               	/* prologue end (size=4) */
 2243               	/* epilogue: frame size=0 */
 2244 0abc DF91      		pop r29
 2245 0abe CF91      		pop r28
 2246 0ac0 0895      		ret
 2247               	/* epilogue end (size=3) */
 2248               	/* function loop size 7 (0) */
 2250               	.Lscope18:
 2252               	.global	main
 2254               	main:
 353:ledmeter.c    ****    // Pb voir ADC (interruption)
 354:ledmeter.c    **** 
 355:ledmeter.c    ****    //inc_time(current_time);
 356:ledmeter.c    **** 
 357:ledmeter.c    ****    //TestRunningChronometer();
 358:ledmeter.c    **** 
 359:ledmeter.c    ****    //show_percent(0x80 * 100 / 0xFF);
 360:ledmeter.c    **** 
 361:ledmeter.c    ****    /*
 362:ledmeter.c    ****    int i;
 363:ledmeter.c    ****    for (i = 0; i<=Nleds; i++) {
 364:ledmeter.c    ****        //switch_on_max_dels(i);
 365:ledmeter.c    ****        switch_on_min_dels(i);
 366:ledmeter.c    ****        _delay_ms(500);
 367:ledmeter.c    ****    }
 368:ledmeter.c    ****    */
 369:ledmeter.c    **** 
 370:ledmeter.c    ****    //show_percent(adcConvert8bit(0));
 371:ledmeter.c    ****    //show_percent(adcConvert8bit(1));
 372:ledmeter.c    **** 
 373:ledmeter.c    ****    /*
 374:ledmeter.c    ****    show_percent(25);
 375:ledmeter.c    ****    _delay_ms(500);
 376:ledmeter.c    ****    show_percent(50);
 377:ledmeter.c    ****    _delay_ms(500);
 378:ledmeter.c    ****    show_percent(100);
 379:ledmeter.c    ****    _delay_ms(500);
 380:ledmeter.c    ****    show_percent(75);
 381:ledmeter.c    ****    _delay_ms(500);
 382:ledmeter.c    ****    show_percent(50);
 383:ledmeter.c    ****    */
 384:ledmeter.c    **** 
 385:ledmeter.c    ****    //led_alarm(3);
 386:ledmeter.c    **** 
 387:ledmeter.c    ****    //test_leds();
 388:ledmeter.c    ****    //switch_on_min_dels(5);
 389:ledmeter.c    ****    //switch_on_max_dels(3);
 390:ledmeter.c    **** 
 391:ledmeter.c    **** 	//switch_on_led(3);
 392:ledmeter.c    **** 	//switch_on_led(5);
 393:ledmeter.c    **** 	//switch_on_led(7);
 394:ledmeter.c    **** 	//switch_on_led(8);	
 395:ledmeter.c    **** 	
 396:ledmeter.c    **** 	//switch_off_led(5);
 397:ledmeter.c    **** }
 398:ledmeter.c    **** 
 399:ledmeter.c    **** 
 400:ledmeter.c    **** /*
 401:ledmeter.c    ****  * main program
 402:ledmeter.c    ****  */
 403:ledmeter.c    **** int main(void) {
 2256               	.LM174:
 2257               	/* prologue: frame size=0 */
 2258 0ac2 C0E0      		ldi r28,lo8(__stack - 0)
 2259 0ac4 D0E0      		ldi r29,hi8(__stack - 0)
 2260 0ac6 DEBF      		out __SP_H__,r29
 2261 0ac8 CDBF      		out __SP_L__,r28
 2262               	/* prologue end (size=4) */
 404:ledmeter.c    ****    init();
 2264               	.LM175:
 2265 0aca 3EDF      		rcall init
 2266               	.L114:
 405:ledmeter.c    **** 
 406:ledmeter.c    ****    while(1) { // Infinite loop; define here the
 407:ledmeter.c    ****       loop(); // system behaviour
 2268               	.LM176:
 2269 0acc F3DF      		rcall loop
 2270 0ace FECF      		rjmp .L114
 2271               	/* epilogue: frame size=0 */
 2272               	/* epilogue: noreturn */
 2273               	/* epilogue end (size=0) */
 2274               	/* function main size 7 (3) */
 2276               	.Lscope19:
 2278               	.global	__vector_1
 2280               	__vector_1:
 408:ledmeter.c    ****    }
 409:ledmeter.c    **** 
 410:ledmeter.c    ****    return 0;
 411:ledmeter.c    **** }
 412:ledmeter.c    **** 
 413:ledmeter.c    **** /*
 414:ledmeter.c    ****  * interrupt handler for INT0
 415:ledmeter.c    ****  */
 416:ledmeter.c    **** SIGNAL(SIG_INTERRUPT0) {
 2282               	.LM177:
 2283               	/* prologue: frame size=0 */
 2284 0ad0 1F92      		push __zero_reg__
 2285 0ad2 0F92      		push __tmp_reg__
 2286 0ad4 0FB6      		in __tmp_reg__,__SREG__
 2287 0ad6 0F92      		push __tmp_reg__
 2288 0ad8 1124      		clr __zero_reg__
 2289 0ada 2F93      		push r18
 2290 0adc 3F93      		push r19
 2291 0ade 4F93      		push r20
 2292 0ae0 5F93      		push r21
 2293 0ae2 6F93      		push r22
 2294 0ae4 7F93      		push r23
 2295 0ae6 8F93      		push r24
 2296 0ae8 9F93      		push r25
 2297 0aea AF93      		push r26
 2298 0aec BF93      		push r27
 2299 0aee EF93      		push r30
 2300 0af0 FF93      		push r31
 2301 0af2 CF93      		push r28
 2302 0af4 DF93      		push r29
 2303 0af6 CDB7      		in r28,__SP_L__
 2304 0af8 DEB7      		in r29,__SP_H__
 2305               	/* prologue end (size=21) */
 417:ledmeter.c    ****     //StartStopChronometer();
 418:ledmeter.c    ****     StartStopChronometer();
 2307               	.LM178:
 2308 0afa 57DE      		rcall StartStopChronometer
 2309               	/* epilogue: frame size=0 */
 2310 0afc DF91      		pop r29
 2311 0afe CF91      		pop r28
 2312 0b00 FF91      		pop r31
 2313 0b02 EF91      		pop r30
 2314 0b04 BF91      		pop r27
 2315 0b06 AF91      		pop r26
 2316 0b08 9F91      		pop r25
 2317 0b0a 8F91      		pop r24
 2318 0b0c 7F91      		pop r23
 2319 0b0e 6F91      		pop r22
 2320 0b10 5F91      		pop r21
 2321 0b12 4F91      		pop r20
 2322 0b14 3F91      		pop r19
 2323 0b16 2F91      		pop r18
 2324 0b18 0F90      		pop __tmp_reg__
 2325 0b1a 0FBE      		out __SREG__,__tmp_reg__
 2326 0b1c 0F90      		pop __tmp_reg__
 2327 0b1e 1F90      		pop __zero_reg__
 2328 0b20 1895      		reti
 2329               	/* epilogue end (size=19) */
 2330               	/* function __vector_1 size 41 (1) */
 2332               	.Lscope20:
 2334               	.global	__vector_14
 2336               	__vector_14:
 419:ledmeter.c    **** }
 420:ledmeter.c    **** 
 421:ledmeter.c    **** /*
 422:ledmeter.c    ****  * interrupt handler for ADC
 423:ledmeter.c    ****  */
 424:ledmeter.c    **** SIGNAL(SIG_ADC) {
 2338               	.LM179:
 2339               	/* prologue: frame size=18 */
 2340 0b22 1F92      		push __zero_reg__
 2341 0b24 0F92      		push __tmp_reg__
 2342 0b26 0FB6      		in __tmp_reg__,__SREG__
 2343 0b28 0F92      		push __tmp_reg__
 2344 0b2a 1124      		clr __zero_reg__
 2345 0b2c 0F93      		push r16
 2346 0b2e 1F93      		push r17
 2347 0b30 2F93      		push r18
 2348 0b32 3F93      		push r19
 2349 0b34 4F93      		push r20
 2350 0b36 5F93      		push r21
 2351 0b38 6F93      		push r22
 2352 0b3a 7F93      		push r23
 2353 0b3c 8F93      		push r24
 2354 0b3e 9F93      		push r25
 2355 0b40 AF93      		push r26
 2356 0b42 BF93      		push r27
 2357 0b44 EF93      		push r30
 2358 0b46 FF93      		push r31
 2359 0b48 CF93      		push r28
 2360 0b4a DF93      		push r29
 2361 0b4c CDB7      		in r28,__SP_L__
 2362 0b4e DEB7      		in r29,__SP_H__
 2363 0b50 6297      		sbiw r28,18
 2364 0b52 DEBF      		out __SP_H__,r29
 2365 0b54 CDBF      		out __SP_L__,r28
 2366               	/* prologue end (size=26) */
 425:ledmeter.c    ****    inc_time(current_time);
 2368               	.LM180:
 2369 0b56 2091 0000 		lds r18,current_time
 2370 0b5a 3091 0000 		lds r19,current_time+1
 2371 0b5e 4091 0000 		lds r20,current_time+2
 2372 0b62 5091 0000 		lds r21,current_time+3
 2373 0b66 6091 0000 		lds r22,current_time+4
 2374 0b6a 7091 0000 		lds r23,current_time+5
 2375 0b6e 8091 0000 		lds r24,current_time+6
 2376 0b72 9091 0000 		lds r25,current_time+7
 2377 0b76 67DA      		rcall inc_time
 426:ledmeter.c    **** 
 427:ledmeter.c    ****    TestRunningChronometer();
 2379               	.LM181:
 2380 0b78 33DE      		rcall TestRunningChronometer
 428:ledmeter.c    **** 
 429:ledmeter.c    ****         unsigned char adlow,adhigh;
 430:ledmeter.c    ****         adlow=ADCL; /* read low first, two lines. Do not combine
 2382               	.LM182:
 2383 0b7a 8091 2400 		lds r24,36
 2384 0b7e 8983      		std Y+1,r24
 431:ledmeter.c    ****                           the two lines into one C statement */
 432:ledmeter.c    ****         adhigh=ADCH;
 2386               	.LM183:
 2387 0b80 8091 2500 		lds r24,37
 2388 0b84 8A83      		std Y+2,r24
 433:ledmeter.c    ****         //analog_result=(adhigh<<8)|(adlow & 0xFF);
 434:ledmeter.c    ****         analog_busy=0;
 2390               	.LM184:
 2391 0b86 1092 0000 		sts (analog_busy)+1,__zero_reg__
 2392 0b8a 1092 0000 		sts analog_busy,__zero_reg__
 435:ledmeter.c    **** 
 436:ledmeter.c    ****         //double ch0 = adcConvert8bit(0) / 2^8 * 100;
 437:ledmeter.c    ****         //double ch0 = adcConvert10bit(0) / 2^10 * 100;
 438:ledmeter.c    ****         double ch0 = adcConvert10bit(0);
 2394               	.LM185:
 2395 0b8e 80E0      		ldi r24,lo8(0)
 2396 0b90 39DF      		rcall adcConvert10bit
 2397 0b92 8C01      		movw r16,r24
 2398 0b94 C801      		movw r24,r16
 2399 0b96 AA27      		clr r26
 2400 0b98 97FD      		sbrc r25,7
 2401 0b9a A095      		com r26
 2402 0b9c BA2F      		mov r27,r26
 2403 0b9e BC01      		movw r22,r24
 2404 0ba0 CD01      		movw r24,r26
 2405 0ba2 00D0      		rcall __floatsisf
 2406 0ba4 6B87      		std Y+11,r22
 2407 0ba6 7C87      		std Y+12,r23
 2408 0ba8 8D87      		std Y+13,r24
 2409 0baa 9E87      		std Y+14,r25
 2410 0bac 1123      		tst r17
 2411 0bae 7CF4      		brge .L118
 2413               	.LM186:
 2414 0bb0 20E0      		ldi r18,lo8(0x47800000)
 2415 0bb2 30E0      		ldi r19,hi8(0x47800000)
 2416 0bb4 40E8      		ldi r20,hlo8(0x47800000)
 2417 0bb6 57E4      		ldi r21,hhi8(0x47800000)
 2418 0bb8 6B85      		ldd r22,Y+11
 2419 0bba 7C85      		ldd r23,Y+12
 2420 0bbc 8D85      		ldd r24,Y+13
 2421 0bbe 9E85      		ldd r25,Y+14
 2422 0bc0 00D0      		rcall __addsf3
 2423 0bc2 DC01      		movw r26,r24
 2424 0bc4 CB01      		movw r24,r22
 2425 0bc6 8B87      		std Y+11,r24
 2426 0bc8 9C87      		std Y+12,r25
 2427 0bca AD87      		std Y+13,r26
 2428 0bcc BE87      		std Y+14,r27
 2429               	.L118:
 2430 0bce 8B85      		ldd r24,Y+11
 2431 0bd0 9C85      		ldd r25,Y+12
 2432 0bd2 AD85      		ldd r26,Y+13
 2433 0bd4 BE85      		ldd r27,Y+14
 2434 0bd6 8B83      		std Y+3,r24
 2435 0bd8 9C83      		std Y+4,r25
 2436 0bda AD83      		std Y+5,r26
 2437 0bdc BE83      		std Y+6,r27
 439:ledmeter.c    ****         double ch1 = adcConvert10bit(1);
 2439               	.LM187:
 2440 0bde 81E0      		ldi r24,lo8(1)
 2441 0be0 11DF      		rcall adcConvert10bit
 2442 0be2 8C01      		movw r16,r24
 2443 0be4 C801      		movw r24,r16
 2444 0be6 AA27      		clr r26
 2445 0be8 97FD      		sbrc r25,7
 2446 0bea A095      		com r26
 2447 0bec BA2F      		mov r27,r26
 2448 0bee BC01      		movw r22,r24
 2449 0bf0 CD01      		movw r24,r26
 2450 0bf2 00D0      		rcall __floatsisf
 2451 0bf4 6F87      		std Y+15,r22
 2452 0bf6 788B      		std Y+16,r23
 2453 0bf8 898B      		std Y+17,r24
 2454 0bfa 9A8B      		std Y+18,r25
 2455 0bfc 1123      		tst r17
 2456 0bfe 7CF4      		brge .L119
 2457 0c00 20E0      		ldi r18,lo8(0x47800000)
 2458 0c02 30E0      		ldi r19,hi8(0x47800000)
 2459 0c04 40E8      		ldi r20,hlo8(0x47800000)
 2460 0c06 57E4      		ldi r21,hhi8(0x47800000)
 2461 0c08 6F85      		ldd r22,Y+15
 2462 0c0a 7889      		ldd r23,Y+16
 2463 0c0c 8989      		ldd r24,Y+17
 2464 0c0e 9A89      		ldd r25,Y+18
 2465 0c10 00D0      		rcall __addsf3
 2466 0c12 DC01      		movw r26,r24
 2467 0c14 CB01      		movw r24,r22
 2468 0c16 8F87      		std Y+15,r24
 2469 0c18 988B      		std Y+16,r25
 2470 0c1a A98B      		std Y+17,r26
 2471 0c1c BA8B      		std Y+18,r27
 2472               	.L119:
 2473 0c1e 8F85      		ldd r24,Y+15
 2474 0c20 9889      		ldd r25,Y+16
 2475 0c22 A989      		ldd r26,Y+17
 2476 0c24 BA89      		ldd r27,Y+18
 2477 0c26 8F83      		std Y+7,r24
 2478 0c28 9887      		std Y+8,r25
 2479 0c2a A987      		std Y+9,r26
 2480 0c2c BA87      		std Y+10,r27
 440:ledmeter.c    ****         ch0 *= 0.09765625; // 0.09765625 = 100 / 2^10
 2482               	.LM188:
 2483 0c2e 20E0      		ldi r18,lo8(0x3dc80000)
 2484 0c30 30E0      		ldi r19,hi8(0x3dc80000)
 2485 0c32 48EC      		ldi r20,hlo8(0x3dc80000)
 2486 0c34 5DE3      		ldi r21,hhi8(0x3dc80000)
 2487 0c36 6B81      		ldd r22,Y+3
 2488 0c38 7C81      		ldd r23,Y+4
 2489 0c3a 8D81      		ldd r24,Y+5
 2490 0c3c 9E81      		ldd r25,Y+6
 2491 0c3e 00D0      		rcall __mulsf3
 2492 0c40 DC01      		movw r26,r24
 2493 0c42 CB01      		movw r24,r22
 2494 0c44 8B83      		std Y+3,r24
 2495 0c46 9C83      		std Y+4,r25
 2496 0c48 AD83      		std Y+5,r26
 2497 0c4a BE83      		std Y+6,r27
 441:ledmeter.c    ****         ch1 *= 0.09765625; // 0.09765625 = 100 / 2^10
 2499               	.LM189:
 2500 0c4c 20E0      		ldi r18,lo8(0x3dc80000)
 2501 0c4e 30E0      		ldi r19,hi8(0x3dc80000)
 2502 0c50 48EC      		ldi r20,hlo8(0x3dc80000)
 2503 0c52 5DE3      		ldi r21,hhi8(0x3dc80000)
 2504 0c54 6F81      		ldd r22,Y+7
 2505 0c56 7885      		ldd r23,Y+8
 2506 0c58 8985      		ldd r24,Y+9
 2507 0c5a 9A85      		ldd r25,Y+10
 2508 0c5c 00D0      		rcall __mulsf3
 2509 0c5e DC01      		movw r26,r24
 2510 0c60 CB01      		movw r24,r22
 2511 0c62 8F83      		std Y+7,r24
 2512 0c64 9887      		std Y+8,r25
 2513 0c66 A987      		std Y+9,r26
 2514 0c68 BA87      		std Y+10,r27
 442:ledmeter.c    ****         show_percent(ch0);
 2516               	.LM190:
 2517 0c6a 6B81      		ldd r22,Y+3
 2518 0c6c 7C81      		ldd r23,Y+4
 2519 0c6e 8D81      		ldd r24,Y+5
 2520 0c70 9E81      		ldd r25,Y+6
 2521 0c72 61DD      		rcall show_percent
 2522               	/* epilogue: frame size=18 */
 2523 0c74 6296      		adiw r28,18
 2524 0c76 F894      		cli
 2525 0c78 DEBF      		out __SP_H__,r29
 2526 0c7a CDBF      		out __SP_L__,r28
 2527 0c7c DF91      		pop r29
 2528 0c7e CF91      		pop r28
 2529 0c80 FF91      		pop r31
 2530 0c82 EF91      		pop r30
 2531 0c84 BF91      		pop r27
 2532 0c86 AF91      		pop r26
 2533 0c88 9F91      		pop r25
 2534 0c8a 8F91      		pop r24
 2535 0c8c 7F91      		pop r23
 2536 0c8e 6F91      		pop r22
 2537 0c90 5F91      		pop r21
 2538 0c92 4F91      		pop r20
 2539 0c94 3F91      		pop r19
 2540 0c96 2F91      		pop r18
 2541 0c98 1F91      		pop r17
 2542 0c9a 0F91      		pop r16
 2543 0c9c 0F90      		pop __tmp_reg__
 2544 0c9e 0FBE      		out __SREG__,__tmp_reg__
 2545 0ca0 0F90      		pop __tmp_reg__
 2546 0ca2 1F90      		pop __zero_reg__
 2547 0ca4 1895      		reti
 2548               	/* epilogue end (size=25) */
 2549               	/* function __vector_14 size 194 (143) */
 2557               	.Lscope21:
 2558               		.comm a2dCompleteFlag,1,1
 2559               		.comm channel,2,1
 2560               		.comm analog_result,2,1
 2561               		.comm analog_busy,2,1
 2562               		.comm current_time,8,1
 2563               		.comm last_time,8,1
 2564               		.comm best_time,8,1
 2573               		.text
 2575               	Letext:
 2576               	/* File "ledmeter.c": code 1636 = 0x0664 (1240), prologues 211, epilogues 185 */
DEFINED SYMBOLS
                            *ABS*:00000000 ledmeter.c
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:3      *ABS*:0000003f __SREG__
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:4      *ABS*:0000003e __SP_H__
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:5      *ABS*:0000003d __SP_L__
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:6      *ABS*:00000000 __tmp_reg__
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:7      *ABS*:00000001 __zero_reg__
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:79     .bss:00000000 running_chronometer
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:86     .text:00000000 init_time
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:143    .text:00000046 inc_time
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:384    .text:00000180 switch_on_all_leds
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:409    .text:00000192 switch_off_all_leds
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:434    .text:000001a6 switch_on_led
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:500    .text:000001fe switch_off_led
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:564    .text:00000252 switch_on_leds_with_delay
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:754    .text:0000033a switch_off_leds_with_delay
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:942    .text:00000420 test_leds
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:1112   .text:000004ee switch_on_min_dels
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:1195   .text:00000552 switch_on_max_dels
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:1281   .text:000005bc led_alarm
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:1593   .text:00000736 show_percent
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:1671   .text:000007aa StartStopChronometer
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:1715   .text:000007e0 TestRunningChronometer
                             .bss:00000002 analog_result.0
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:2002   .bss:00000004 analog_busy.1
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:2007   .text:00000948 init
                            *COM*:00000002 channel
                            *COM*:00000008 current_time
                            *COM*:00000008 last_time
                            *COM*:00000008 best_time
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:2113   .text:00000a04 adcConvert10bit
                            *COM*:00000001 a2dCompleteFlag
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:2192   .text:00000a7e adcConvert8bit
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:2234   .text:00000ab4 loop
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:2254   .text:00000ac2 main
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:2280   .text:00000ad0 __vector_1
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:2336   .text:00000b22 __vector_14
                            *COM*:00000002 analog_busy
                            *COM*:00000002 analog_result
C:\DOCUME~1\scls\LOCALS~1\Temp/ccOcaaaa.s:2575   .text:00000ca6 Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__mulsf3
__ltsf2
__gtsf2
__fixunssfsi
__divsf3
floor
__fixsfsi
__stack
__floatsisf
__addsf3
