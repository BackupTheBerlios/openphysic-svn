   1               		.file	"ledmeter.c"
   2               		.arch atmega8535
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  74               	.global	switch_on_all_leds
  76               	switch_on_all_leds:
   1:ledmeter.c    **** // ***********************************************************
   2:ledmeter.c    **** // Project: OpenChrono
   3:ledmeter.c    **** // Author: Sebastien CELLES
   4:ledmeter.c    **** // Module description: an handhelds device for karts, bike or sport cars
   5:ledmeter.c    **** // ***********************************************************
   6:ledmeter.c    **** 
   7:ledmeter.c    **** #include <avr/io.h>              // Most basic include files
   8:ledmeter.c    **** 
   9:ledmeter.c    **** #include <math.h>
  10:ledmeter.c    **** 
  11:ledmeter.c    **** #define F_CPU 1000000UL  // 1 MHz
  12:ledmeter.c    **** #include <avr/delay.h>
  13:ledmeter.c    **** 
  14:ledmeter.c    **** //#include <avr/io.h>              // Most basic include files
  15:ledmeter.c    **** #include <avr/interrupt.h>       // Add the necessary ones
  16:ledmeter.c    **** //#include <avr/signal.h>          // here
  17:ledmeter.c    **** 
  18:ledmeter.c    **** 
  19:ledmeter.c    **** volatile unsigned char a2dCompleteFlag;
  20:ledmeter.c    **** 
  21:ledmeter.c    **** 
  22:ledmeter.c    **** #define Nleds 8  // number of leds connected to the uC
  23:ledmeter.c    **** 
  24:ledmeter.c    **** #define N 50 // number between 0 and 255
  25:ledmeter.c    **** #define Nmax 0xFF
  26:ledmeter.c    **** 
  27:ledmeter.c    **** 
  28:ledmeter.c    **** 
  29:ledmeter.c    **** /*
  30:ledmeter.c    **** void switch_on_all_leds();
  31:ledmeter.c    **** void switch_off_all_leds();
  32:ledmeter.c    **** void switch_on_led(int led);
  33:ledmeter.c    **** void switch_off_led(int led);
  34:ledmeter.c    **** void loop(void);
  35:ledmeter.c    **** void init(void);
  36:ledmeter.c    **** */
  37:ledmeter.c    **** 
  38:ledmeter.c    **** // 1=off
  39:ledmeter.c    **** // 0=on
  40:ledmeter.c    **** 
  41:ledmeter.c    **** /*
  42:ledmeter.c    ****  *
  43:ledmeter.c    ****  */
  44:ledmeter.c    **** void switch_on_all_leds() {
  78               	.LM1:
  79               	/* prologue: frame size=0 */
  80 0000 CF93      		push r28
  81 0002 DF93      		push r29
  82 0004 CDB7      		in r28,__SP_L__
  83 0006 DEB7      		in r29,__SP_H__
  84               	/* prologue end (size=4) */
  45:ledmeter.c    ****     PORTC = 0x00;
  86               	.LM2:
  87 0008 1092 3500 		sts 53,__zero_reg__
  88               	/* epilogue: frame size=0 */
  89 000c DF91      		pop r29
  90 000e CF91      		pop r28
  91 0010 0895      		ret
  92               	/* epilogue end (size=3) */
  93               	/* function switch_on_all_leds size 9 (2) */
  95               	.Lscope0:
  97               	.global	switch_off_all_leds
  99               	switch_off_all_leds:
  46:ledmeter.c    **** }
  47:ledmeter.c    **** 
  48:ledmeter.c    **** /*
  49:ledmeter.c    ****  *
  50:ledmeter.c    ****  */
  51:ledmeter.c    **** void switch_off_all_leds() {
 101               	.LM3:
 102               	/* prologue: frame size=0 */
 103 0012 CF93      		push r28
 104 0014 DF93      		push r29
 105 0016 CDB7      		in r28,__SP_L__
 106 0018 DEB7      		in r29,__SP_H__
 107               	/* prologue end (size=4) */
  52:ledmeter.c    ****     PORTC = 0xFF;
 109               	.LM4:
 110 001a 8FEF      		ldi r24,lo8(-1)
 111 001c 8093 3500 		sts 53,r24
 112               	/* epilogue: frame size=0 */
 113 0020 DF91      		pop r29
 114 0022 CF91      		pop r28
 115 0024 0895      		ret
 116               	/* epilogue end (size=3) */
 117               	/* function switch_off_all_leds size 10 (3) */
 119               	.Lscope1:
 122               	.global	switch_on_led
 124               	switch_on_led:
  53:ledmeter.c    **** }
  54:ledmeter.c    **** 
  55:ledmeter.c    **** // led from 1 to 8 (LEDSNUM)
  56:ledmeter.c    **** // PCx with w from 0 to 7
  57:ledmeter.c    **** 
  58:ledmeter.c    **** /*
  59:ledmeter.c    ****  *  switch on the led with the number called "led"
  60:ledmeter.c    ****  */
  61:ledmeter.c    **** void switch_on_led(int led) {
 126               	.LM5:
 127               	/* prologue: frame size=6 */
 128 0026 CF93      		push r28
 129 0028 DF93      		push r29
 130 002a CDB7      		in r28,__SP_L__
 131 002c DEB7      		in r29,__SP_H__
 132 002e 2697      		sbiw r28,6
 133 0030 0FB6      		in __tmp_reg__,__SREG__
 134 0032 F894      		cli
 135 0034 DEBF      		out __SP_H__,r29
 136 0036 0FBE      		out __SREG__,__tmp_reg__
 137 0038 CDBF      		out __SP_L__,r28
 138               	/* prologue end (size=10) */
 139 003a 9A83      		std Y+2,r25
 140 003c 8983      		std Y+1,r24
  62:ledmeter.c    ****     int pin = led - 1;
 142               	.LM6:
 143 003e 8981      		ldd r24,Y+1
 144 0040 9A81      		ldd r25,Y+2
 145 0042 0197      		sbiw r24,1
 146 0044 9C83      		std Y+4,r25
 147 0046 8B83      		std Y+3,r24
  63:ledmeter.c    ****     int mask = ~(1<<pin);
 149               	.LM7:
 150 0048 81E0      		ldi r24,lo8(1)
 151 004a 90E0      		ldi r25,hi8(1)
 152 004c 0B80      		ldd r0,Y+3
 153 004e 02C0      		rjmp 2f
 154 0050 880F      	1:	lsl r24
 155 0052 991F      		rol r25
 156 0054 0A94      	2:	dec r0
 157 0056 E2F7      		brpl 1b
 158 0058 8095      		com r24
 159 005a 9095      		com r25
 160 005c 9E83      		std Y+6,r25
 161 005e 8D83      		std Y+5,r24
  64:ledmeter.c    ****     PORTC&=mask;
 163               	.LM8:
 164 0060 9091 3500 		lds r25,53
 165 0064 8D81      		ldd r24,Y+5
 166 0066 8923      		and r24,r25
 167 0068 8093 3500 		sts 53,r24
 168               	/* epilogue: frame size=6 */
 169 006c 2696      		adiw r28,6
 170 006e 0FB6      		in __tmp_reg__,__SREG__
 171 0070 F894      		cli
 172 0072 DEBF      		out __SP_H__,r29
 173 0074 0FBE      		out __SREG__,__tmp_reg__
 174 0076 CDBF      		out __SP_L__,r28
 175 0078 DF91      		pop r29
 176 007a CF91      		pop r28
 177 007c 0895      		ret
 178               	/* epilogue end (size=9) */
 179               	/* function switch_on_led size 44 (25) */
 185               	.Lscope2:
 188               	.global	switch_off_led
 190               	switch_off_led:
  65:ledmeter.c    **** }
  66:ledmeter.c    **** 
  67:ledmeter.c    **** /*
  68:ledmeter.c    ****  *  switch off the led with the number called "led"
  69:ledmeter.c    ****  */
  70:ledmeter.c    **** void switch_off_led(int led) {
 192               	.LM9:
 193               	/* prologue: frame size=6 */
 194 007e CF93      		push r28
 195 0080 DF93      		push r29
 196 0082 CDB7      		in r28,__SP_L__
 197 0084 DEB7      		in r29,__SP_H__
 198 0086 2697      		sbiw r28,6
 199 0088 0FB6      		in __tmp_reg__,__SREG__
 200 008a F894      		cli
 201 008c DEBF      		out __SP_H__,r29
 202 008e 0FBE      		out __SREG__,__tmp_reg__
 203 0090 CDBF      		out __SP_L__,r28
 204               	/* prologue end (size=10) */
 205 0092 9A83      		std Y+2,r25
 206 0094 8983      		std Y+1,r24
  71:ledmeter.c    ****     int pin = led - 1;
 208               	.LM10:
 209 0096 8981      		ldd r24,Y+1
 210 0098 9A81      		ldd r25,Y+2
 211 009a 0197      		sbiw r24,1
 212 009c 9C83      		std Y+4,r25
 213 009e 8B83      		std Y+3,r24
  72:ledmeter.c    ****     int mask = (1<<pin);
 215               	.LM11:
 216 00a0 81E0      		ldi r24,lo8(1)
 217 00a2 90E0      		ldi r25,hi8(1)
 218 00a4 0B80      		ldd r0,Y+3
 219 00a6 02C0      		rjmp 2f
 220 00a8 880F      	1:	lsl r24
 221 00aa 991F      		rol r25
 222 00ac 0A94      	2:	dec r0
 223 00ae E2F7      		brpl 1b
 224 00b0 9E83      		std Y+6,r25
 225 00b2 8D83      		std Y+5,r24
  73:ledmeter.c    ****     PORTC|=mask;
 227               	.LM12:
 228 00b4 9091 3500 		lds r25,53
 229 00b8 8D81      		ldd r24,Y+5
 230 00ba 892B      		or r24,r25
 231 00bc 8093 3500 		sts 53,r24
 232               	/* epilogue: frame size=6 */
 233 00c0 2696      		adiw r28,6
 234 00c2 0FB6      		in __tmp_reg__,__SREG__
 235 00c4 F894      		cli
 236 00c6 DEBF      		out __SP_H__,r29
 237 00c8 0FBE      		out __SREG__,__tmp_reg__
 238 00ca CDBF      		out __SP_L__,r28
 239 00cc DF91      		pop r29
 240 00ce CF91      		pop r28
 241 00d0 0895      		ret
 242               	/* epilogue end (size=9) */
 243               	/* function switch_off_led size 42 (23) */
 249               	.Lscope3:
 252               	.global	switch_on_leds_with_delay
 254               	switch_on_leds_with_delay:
  74:ledmeter.c    **** }
  75:ledmeter.c    **** 
  76:ledmeter.c    **** /*
  77:ledmeter.c    ****  *  switch on every leds one after one with a delay (called "delay")
  78:ledmeter.c    ****  */
  79:ledmeter.c    **** void switch_on_leds_with_delay(double delay) {
 256               	.LM13:
 257               	/* prologue: frame size=18 */
 258 00d2 CF93      		push r28
 259 00d4 DF93      		push r29
 260 00d6 CDB7      		in r28,__SP_L__
 261 00d8 DEB7      		in r29,__SP_H__
 262 00da 6297      		sbiw r28,18
 263 00dc 0FB6      		in __tmp_reg__,__SREG__
 264 00de F894      		cli
 265 00e0 DEBF      		out __SP_H__,r29
 266 00e2 0FBE      		out __SREG__,__tmp_reg__
 267 00e4 CDBF      		out __SP_L__,r28
 268               	/* prologue end (size=10) */
 269 00e6 6983      		std Y+1,r22
 270 00e8 7A83      		std Y+2,r23
 271 00ea 8B83      		std Y+3,r24
 272 00ec 9C83      		std Y+4,r25
  80:ledmeter.c    ****     int i;
  81:ledmeter.c    ****     for(i = 1; i<=Nleds; i++) {
 274               	.LM14:
 275 00ee 81E0      		ldi r24,lo8(1)
 276 00f0 90E0      		ldi r25,hi8(1)
 277 00f2 9E83      		std Y+6,r25
 278 00f4 8D83      		std Y+5,r24
 279               	.L6:
 281               	.LM15:
 282 00f6 8D81      		ldd r24,Y+5
 283 00f8 9E81      		ldd r25,Y+6
 284 00fa 8930      		cpi r24,9
 285 00fc 9105      		cpc r25,__zero_reg__
 286 00fe 0CF0      		brlt .+2
 287 0100 53C0      		rjmp .L5
 288               	.LBB2:
 290               	.Ltext1:
   1:C:/WinAVR/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:C:/WinAVR/avr/include/util/delay.h ****    Copyright (c) 2004,2005 Joerg Wunsch
   3:C:/WinAVR/avr/include/util/delay.h ****    All rights reserved.
   4:C:/WinAVR/avr/include/util/delay.h **** 
   5:C:/WinAVR/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   6:C:/WinAVR/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   7:C:/WinAVR/avr/include/util/delay.h **** 
   8:C:/WinAVR/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
   9:C:/WinAVR/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  10:C:/WinAVR/avr/include/util/delay.h **** 
  11:C:/WinAVR/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  12:C:/WinAVR/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  13:C:/WinAVR/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  14:C:/WinAVR/avr/include/util/delay.h ****      distribution.
  15:C:/WinAVR/avr/include/util/delay.h **** 
  16:C:/WinAVR/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  17:C:/WinAVR/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  18:C:/WinAVR/avr/include/util/delay.h ****      from this software without specific prior written permission.
  19:C:/WinAVR/avr/include/util/delay.h **** 
  20:C:/WinAVR/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:C:/WinAVR/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:C:/WinAVR/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:C:/WinAVR/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:C:/WinAVR/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:C:/WinAVR/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:C:/WinAVR/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:C:/WinAVR/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:C:/WinAVR/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:C:/WinAVR/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:C:/WinAVR/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:C:/WinAVR/avr/include/util/delay.h **** 
  32:C:/WinAVR/avr/include/util/delay.h **** /* $Id: delay.h,v 1.1.2.1 2005/12/12 23:19:49 joerg_wunsch Exp $ */
  33:C:/WinAVR/avr/include/util/delay.h **** 
  34:C:/WinAVR/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  35:C:/WinAVR/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  36:C:/WinAVR/avr/include/util/delay.h **** 
  37:C:/WinAVR/avr/include/util/delay.h **** #include <inttypes.h>
  38:C:/WinAVR/avr/include/util/delay.h **** 
  39:C:/WinAVR/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Busy-wait delay loops
  40:C:/WinAVR/avr/include/util/delay.h ****     \code
  41:C:/WinAVR/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  42:C:/WinAVR/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  43:C:/WinAVR/avr/include/util/delay.h ****     #include <util/delay.h>
  44:C:/WinAVR/avr/include/util/delay.h ****     \endcode
  45:C:/WinAVR/avr/include/util/delay.h **** 
  46:C:/WinAVR/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  47:C:/WinAVR/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  48:C:/WinAVR/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  49:C:/WinAVR/avr/include/util/delay.h ****     used.
  50:C:/WinAVR/avr/include/util/delay.h **** 
  51:C:/WinAVR/avr/include/util/delay.h ****     The functions in this header file implement simple delay loops
  52:C:/WinAVR/avr/include/util/delay.h ****     that perform a busy-waiting.  They are typically used to
  53:C:/WinAVR/avr/include/util/delay.h ****     facilitate short delays in the program execution.  They are
  54:C:/WinAVR/avr/include/util/delay.h ****     implemented as count-down loops with a well-known CPU cycle
  55:C:/WinAVR/avr/include/util/delay.h ****     count per loop iteration.  As such, no other processing can
  56:C:/WinAVR/avr/include/util/delay.h ****     occur simultaneously.  It should be kept in mind that the
  57:C:/WinAVR/avr/include/util/delay.h ****     functions described here do not disable interrupts.
  58:C:/WinAVR/avr/include/util/delay.h **** 
  59:C:/WinAVR/avr/include/util/delay.h ****     In general, for long delays, the use of hardware timers is
  60:C:/WinAVR/avr/include/util/delay.h ****     much preferrable, as they free the CPU, and allow for
  61:C:/WinAVR/avr/include/util/delay.h ****     concurrent processing of other events while the timer is
  62:C:/WinAVR/avr/include/util/delay.h ****     running.  However, in particular for very short delays, the
  63:C:/WinAVR/avr/include/util/delay.h ****     overhead of setting up a hardware timer is too much compared
  64:C:/WinAVR/avr/include/util/delay.h ****     to the overall delay time.
  65:C:/WinAVR/avr/include/util/delay.h **** 
  66:C:/WinAVR/avr/include/util/delay.h ****     Two inline functions are provided for the actual delay algorithms.
  67:C:/WinAVR/avr/include/util/delay.h **** 
  68:C:/WinAVR/avr/include/util/delay.h ****     Two wrapper functions allow the specification of microsecond, and
  69:C:/WinAVR/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  70:C:/WinAVR/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).  These functions
  71:C:/WinAVR/avr/include/util/delay.h ****     operate on double typed arguments, however when optimization is
  72:C:/WinAVR/avr/include/util/delay.h ****     turned on, the entire floating-point calculation will be done at
  73:C:/WinAVR/avr/include/util/delay.h ****     compile-time.
  74:C:/WinAVR/avr/include/util/delay.h **** 
  75:C:/WinAVR/avr/include/util/delay.h ****     \note When using _delay_us() and _delay_ms(), the expressions
  76:C:/WinAVR/avr/include/util/delay.h ****     passed as arguments to these functions shall be compile-time
  77:C:/WinAVR/avr/include/util/delay.h ****     constants, otherwise the floating-point calculations to setup the
  78:C:/WinAVR/avr/include/util/delay.h ****     loops will be done at run-time, thereby drastically increasing
  79:C:/WinAVR/avr/include/util/delay.h ****     both the resulting code size, as well as the time required to
  80:C:/WinAVR/avr/include/util/delay.h ****     setup the loops.
  81:C:/WinAVR/avr/include/util/delay.h **** */
  82:C:/WinAVR/avr/include/util/delay.h **** 
  83:C:/WinAVR/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:C:/WinAVR/avr/include/util/delay.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  85:C:/WinAVR/avr/include/util/delay.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  86:C:/WinAVR/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  87:C:/WinAVR/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  88:C:/WinAVR/avr/include/util/delay.h **** #endif
  89:C:/WinAVR/avr/include/util/delay.h **** 
  90:C:/WinAVR/avr/include/util/delay.h **** /** \ingroup util_delay
  91:C:/WinAVR/avr/include/util/delay.h **** 
  92:C:/WinAVR/avr/include/util/delay.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  93:C:/WinAVR/avr/include/util/delay.h ****     iterations are possible.  (The value 256 would have to be passed
  94:C:/WinAVR/avr/include/util/delay.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  95:C:/WinAVR/avr/include/util/delay.h ****     including the overhead the compiler needs to setup the counter
  96:C:/WinAVR/avr/include/util/delay.h ****     register.
  97:C:/WinAVR/avr/include/util/delay.h **** 
  98:C:/WinAVR/avr/include/util/delay.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  99:C:/WinAVR/avr/include/util/delay.h ****     can be achieved.
 100:C:/WinAVR/avr/include/util/delay.h **** */
 101:C:/WinAVR/avr/include/util/delay.h **** void
 102:C:/WinAVR/avr/include/util/delay.h **** _delay_loop_1(uint8_t __count)
 103:C:/WinAVR/avr/include/util/delay.h **** {
 104:C:/WinAVR/avr/include/util/delay.h **** 	__asm__ volatile (
 105:C:/WinAVR/avr/include/util/delay.h **** 		"1: dec %0" "\n\t"
 106:C:/WinAVR/avr/include/util/delay.h **** 		"brne 1b"
 107:C:/WinAVR/avr/include/util/delay.h **** 		: "=r" (__count)
 108:C:/WinAVR/avr/include/util/delay.h **** 		: "0" (__count)
 109:C:/WinAVR/avr/include/util/delay.h **** 	);
 110:C:/WinAVR/avr/include/util/delay.h **** }
 111:C:/WinAVR/avr/include/util/delay.h **** 
 112:C:/WinAVR/avr/include/util/delay.h **** /** \ingroup util_delay
 113:C:/WinAVR/avr/include/util/delay.h **** 
 114:C:/WinAVR/avr/include/util/delay.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
 115:C:/WinAVR/avr/include/util/delay.h ****     iterations are possible.  (The value 65536 would have to be
 116:C:/WinAVR/avr/include/util/delay.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
 117:C:/WinAVR/avr/include/util/delay.h ****     not including the overhead the compiler requires to setup the
 118:C:/WinAVR/avr/include/util/delay.h ****     counter register pair.
 119:C:/WinAVR/avr/include/util/delay.h **** 
 120:C:/WinAVR/avr/include/util/delay.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 121:C:/WinAVR/avr/include/util/delay.h ****     milliseconds can be achieved.
 122:C:/WinAVR/avr/include/util/delay.h ****  */
 123:C:/WinAVR/avr/include/util/delay.h **** void
 124:C:/WinAVR/avr/include/util/delay.h **** _delay_loop_2(uint16_t __count)
 125:C:/WinAVR/avr/include/util/delay.h **** {
 126:C:/WinAVR/avr/include/util/delay.h **** 	__asm__ volatile (
 127:C:/WinAVR/avr/include/util/delay.h **** 		"1: sbiw %0,1" "\n\t"
 128:C:/WinAVR/avr/include/util/delay.h **** 		"brne 1b"
 129:C:/WinAVR/avr/include/util/delay.h **** 		: "=w" (__count)
 130:C:/WinAVR/avr/include/util/delay.h **** 		: "0" (__count)
 131:C:/WinAVR/avr/include/util/delay.h **** 	);
 132:C:/WinAVR/avr/include/util/delay.h **** }
 133:C:/WinAVR/avr/include/util/delay.h **** 
 134:C:/WinAVR/avr/include/util/delay.h **** #ifndef F_CPU
 135:C:/WinAVR/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
 136:C:/WinAVR/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
 137:C:/WinAVR/avr/include/util/delay.h **** # define F_CPU 1000000UL
 138:C:/WinAVR/avr/include/util/delay.h **** #endif
 139:C:/WinAVR/avr/include/util/delay.h **** 
 140:C:/WinAVR/avr/include/util/delay.h **** /**
 141:C:/WinAVR/avr/include/util/delay.h ****    \ingroup util_delay
 142:C:/WinAVR/avr/include/util/delay.h **** 
 143:C:/WinAVR/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 144:C:/WinAVR/avr/include/util/delay.h **** 
 145:C:/WinAVR/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 146:C:/WinAVR/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 147:C:/WinAVR/avr/include/util/delay.h **** 
 148:C:/WinAVR/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 149:C:/WinAVR/avr/include/util/delay.h ****  */
 150:C:/WinAVR/avr/include/util/delay.h **** void
 151:C:/WinAVR/avr/include/util/delay.h **** _delay_us(double __us)
 152:C:/WinAVR/avr/include/util/delay.h **** {
 153:C:/WinAVR/avr/include/util/delay.h **** 	uint8_t __ticks;
 154:C:/WinAVR/avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 3e6) * __us;
 155:C:/WinAVR/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 156:C:/WinAVR/avr/include/util/delay.h **** 		__ticks = 1;
 157:C:/WinAVR/avr/include/util/delay.h **** 	else if (__tmp > 255)
 158:C:/WinAVR/avr/include/util/delay.h **** 		__ticks = 0;	/* i.e. 256 */
 159:C:/WinAVR/avr/include/util/delay.h **** 	else
 160:C:/WinAVR/avr/include/util/delay.h **** 		__ticks = (uint8_t)__tmp;
 161:C:/WinAVR/avr/include/util/delay.h **** 	_delay_loop_1(__ticks);
 162:C:/WinAVR/avr/include/util/delay.h **** }
 163:C:/WinAVR/avr/include/util/delay.h **** 
 164:C:/WinAVR/avr/include/util/delay.h **** 
 165:C:/WinAVR/avr/include/util/delay.h **** /**
 166:C:/WinAVR/avr/include/util/delay.h ****    \ingroup util_delay
 167:C:/WinAVR/avr/include/util/delay.h **** 
 168:C:/WinAVR/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 169:C:/WinAVR/avr/include/util/delay.h **** 
 170:C:/WinAVR/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 171:C:/WinAVR/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 172:C:/WinAVR/avr/include/util/delay.h **** 
 173:C:/WinAVR/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 174:C:/WinAVR/avr/include/util/delay.h ****  */
 175:C:/WinAVR/avr/include/util/delay.h **** void
 176:C:/WinAVR/avr/include/util/delay.h **** _delay_ms(double __ms)
 177:C:/WinAVR/avr/include/util/delay.h **** {
 292               	.LM16:
 293 0102 8981      		ldd r24,Y+1
 294 0104 9A81      		ldd r25,Y+2
 295 0106 AB81      		ldd r26,Y+3
 296 0108 BC81      		ldd r27,Y+4
 297 010a 8F83      		std Y+7,r24
 298 010c 9887      		std Y+8,r25
 299 010e A987      		std Y+9,r26
 300 0110 BA87      		std Y+10,r27
 301               	.LBB3:
 178:C:/WinAVR/avr/include/util/delay.h **** 	uint16_t __ticks;
 179:C:/WinAVR/avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 4e3) * __ms;
 303               	.LM17:
 304 0112 20E0      		ldi r18,lo8(0x437a0000)
 305 0114 30E0      		ldi r19,hi8(0x437a0000)
 306 0116 4AE7      		ldi r20,hlo8(0x437a0000)
 307 0118 53E4      		ldi r21,hhi8(0x437a0000)
 308 011a 6F81      		ldd r22,Y+7
 309 011c 7885      		ldd r23,Y+8
 310 011e 8985      		ldd r24,Y+9
 311 0120 9A85      		ldd r25,Y+10
 312 0122 00D0      		rcall __mulsf3
 313 0124 DC01      		movw r26,r24
 314 0126 CB01      		movw r24,r22
 315 0128 8D87      		std Y+13,r24
 316 012a 9E87      		std Y+14,r25
 317 012c AF87      		std Y+15,r26
 318 012e B88B      		std Y+16,r27
 180:C:/WinAVR/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 320               	.LM18:
 321 0130 20E0      		ldi r18,lo8(0x3f800000)
 322 0132 30E0      		ldi r19,hi8(0x3f800000)
 323 0134 40E8      		ldi r20,hlo8(0x3f800000)
 324 0136 5FE3      		ldi r21,hhi8(0x3f800000)
 325 0138 6D85      		ldd r22,Y+13
 326 013a 7E85      		ldd r23,Y+14
 327 013c 8F85      		ldd r24,Y+15
 328 013e 9889      		ldd r25,Y+16
 329 0140 00D0      		rcall __ltsf2
 330 0142 8823      		tst r24
 331 0144 0CF0      		brlt .L10
 332 0146 05C0      		rjmp .L9
 333               	.L10:
 181:C:/WinAVR/avr/include/util/delay.h **** 		__ticks = 1;
 335               	.LM19:
 336 0148 81E0      		ldi r24,lo8(1)
 337 014a 90E0      		ldi r25,hi8(1)
 338 014c 9C87      		std Y+12,r25
 339 014e 8B87      		std Y+11,r24
 340 0150 18C0      		rjmp .L11
 341               	.L9:
 182:C:/WinAVR/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 343               	.LM20:
 344 0152 20E0      		ldi r18,lo8(0x477fff00)
 345 0154 3FEF      		ldi r19,hi8(0x477fff00)
 346 0156 4FE7      		ldi r20,hlo8(0x477fff00)
 347 0158 57E4      		ldi r21,hhi8(0x477fff00)
 348 015a 6D85      		ldd r22,Y+13
 349 015c 7E85      		ldd r23,Y+14
 350 015e 8F85      		ldd r24,Y+15
 351 0160 9889      		ldd r25,Y+16
 352 0162 00D0      		rcall __gtsf2
 353 0164 1816      		cp __zero_reg__,r24
 354 0166 0CF0      		brlt .L13
 355 0168 03C0      		rjmp .L12
 356               	.L13:
 183:C:/WinAVR/avr/include/util/delay.h **** 		__ticks = 0;	/* i.e. 65536 */
 358               	.LM21:
 359 016a 1C86      		std Y+12,__zero_reg__
 360 016c 1B86      		std Y+11,__zero_reg__
 361 016e 09C0      		rjmp .L11
 362               	.L12:
 184:C:/WinAVR/avr/include/util/delay.h **** 	else
 185:C:/WinAVR/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 364               	.LM22:
 365 0170 6D85      		ldd r22,Y+13
 366 0172 7E85      		ldd r23,Y+14
 367 0174 8F85      		ldd r24,Y+15
 368 0176 9889      		ldd r25,Y+16
 369 0178 00D0      		rcall __fixunssfsi
 370 017a DC01      		movw r26,r24
 371 017c CB01      		movw r24,r22
 372 017e 9C87      		std Y+12,r25
 373 0180 8B87      		std Y+11,r24
 374               	.L11:
 375               	.LBB4:
 377               	.LM23:
 378 0182 8B85      		ldd r24,Y+11
 379 0184 9C85      		ldd r25,Y+12
 380 0186 9A8B      		std Y+18,r25
 381 0188 898B      		std Y+17,r24
 382               	.LBB5:
 384               	.LM24:
 385 018a 8989      		ldd r24,Y+17
 386 018c 9A89      		ldd r25,Y+18
 387               	/* #APP */
 388 018e 0197      		1: sbiw r24,1
 389 0190 F1F7      		brne 1b
 390               	/* #NOAPP */
 391 0192 9A8B      		std Y+18,r25
 392 0194 898B      		std Y+17,r24
 393               	.LBE5:
 394               	.LBE4:
 395               	.LBE3:
 396               	.LBE2:
 398               	.Ltext2:
  82:ledmeter.c    ****         _delay_ms(delay);
  83:ledmeter.c    ****         switch_on_led(i);
 400               	.LM25:
 401 0196 8D81      		ldd r24,Y+5
 402 0198 9E81      		ldd r25,Y+6
 403 019a 45DF      		rcall switch_on_led
 405               	.LM26:
 406 019c 8D81      		ldd r24,Y+5
 407 019e 9E81      		ldd r25,Y+6
 408 01a0 0196      		adiw r24,1
 409 01a2 9E83      		std Y+6,r25
 410 01a4 8D83      		std Y+5,r24
 411 01a6 A7CF      		rjmp .L6
 412               	.L5:
 413               	/* epilogue: frame size=18 */
 414 01a8 6296      		adiw r28,18
 415 01aa 0FB6      		in __tmp_reg__,__SREG__
 416 01ac F894      		cli
 417 01ae DEBF      		out __SP_H__,r29
 418 01b0 0FBE      		out __SREG__,__tmp_reg__
 419 01b2 CDBF      		out __SP_L__,r28
 420 01b4 DF91      		pop r29
 421 01b6 CF91      		pop r28
 422 01b8 0895      		ret
 423               	/* epilogue end (size=9) */
 424               	/* function switch_on_leds_with_delay size 118 (99) */
 439               	.Lscope4:
 442               	.global	switch_off_leds_with_delay
 444               	switch_off_leds_with_delay:
  84:ledmeter.c    ****     }
  85:ledmeter.c    **** }
  86:ledmeter.c    **** 
  87:ledmeter.c    **** /*
  88:ledmeter.c    ****  *  switch off every leds on after one with a delay (called "delay")
  89:ledmeter.c    ****  */
  90:ledmeter.c    **** void switch_off_leds_with_delay(double delay) {
 446               	.LM27:
 447               	/* prologue: frame size=18 */
 448 01ba CF93      		push r28
 449 01bc DF93      		push r29
 450 01be CDB7      		in r28,__SP_L__
 451 01c0 DEB7      		in r29,__SP_H__
 452 01c2 6297      		sbiw r28,18
 453 01c4 0FB6      		in __tmp_reg__,__SREG__
 454 01c6 F894      		cli
 455 01c8 DEBF      		out __SP_H__,r29
 456 01ca 0FBE      		out __SREG__,__tmp_reg__
 457 01cc CDBF      		out __SP_L__,r28
 458               	/* prologue end (size=10) */
 459 01ce 6983      		std Y+1,r22
 460 01d0 7A83      		std Y+2,r23
 461 01d2 8B83      		std Y+3,r24
 462 01d4 9C83      		std Y+4,r25
  91:ledmeter.c    ****     int i;
  92:ledmeter.c    ****     for(i = Nleds; i>=0; i--) {
 464               	.LM28:
 465 01d6 88E0      		ldi r24,lo8(8)
 466 01d8 90E0      		ldi r25,hi8(8)
 467 01da 9E83      		std Y+6,r25
 468 01dc 8D83      		std Y+5,r24
 469               	.L18:
 471               	.LM29:
 472 01de 8D81      		ldd r24,Y+5
 473 01e0 9E81      		ldd r25,Y+6
 474 01e2 9923      		tst r25
 475 01e4 0CF4      		brge .+2
 476 01e6 53C0      		rjmp .L17
 477               	.LBB6:
 479               	.Ltext3:
 481               	.LM30:
 482 01e8 8981      		ldd r24,Y+1
 483 01ea 9A81      		ldd r25,Y+2
 484 01ec AB81      		ldd r26,Y+3
 485 01ee BC81      		ldd r27,Y+4
 486 01f0 8F83      		std Y+7,r24
 487 01f2 9887      		std Y+8,r25
 488 01f4 A987      		std Y+9,r26
 489 01f6 BA87      		std Y+10,r27
 490               	.LBB7:
 492               	.LM31:
 493 01f8 20E0      		ldi r18,lo8(0x437a0000)
 494 01fa 30E0      		ldi r19,hi8(0x437a0000)
 495 01fc 4AE7      		ldi r20,hlo8(0x437a0000)
 496 01fe 53E4      		ldi r21,hhi8(0x437a0000)
 497 0200 6F81      		ldd r22,Y+7
 498 0202 7885      		ldd r23,Y+8
 499 0204 8985      		ldd r24,Y+9
 500 0206 9A85      		ldd r25,Y+10
 501 0208 00D0      		rcall __mulsf3
 502 020a DC01      		movw r26,r24
 503 020c CB01      		movw r24,r22
 504 020e 8D87      		std Y+13,r24
 505 0210 9E87      		std Y+14,r25
 506 0212 AF87      		std Y+15,r26
 507 0214 B88B      		std Y+16,r27
 509               	.LM32:
 510 0216 20E0      		ldi r18,lo8(0x3f800000)
 511 0218 30E0      		ldi r19,hi8(0x3f800000)
 512 021a 40E8      		ldi r20,hlo8(0x3f800000)
 513 021c 5FE3      		ldi r21,hhi8(0x3f800000)
 514 021e 6D85      		ldd r22,Y+13
 515 0220 7E85      		ldd r23,Y+14
 516 0222 8F85      		ldd r24,Y+15
 517 0224 9889      		ldd r25,Y+16
 518 0226 00D0      		rcall __ltsf2
 519 0228 8823      		tst r24
 520 022a 0CF0      		brlt .L22
 521 022c 05C0      		rjmp .L21
 522               	.L22:
 524               	.LM33:
 525 022e 81E0      		ldi r24,lo8(1)
 526 0230 90E0      		ldi r25,hi8(1)
 527 0232 9C87      		std Y+12,r25
 528 0234 8B87      		std Y+11,r24
 529 0236 18C0      		rjmp .L23
 530               	.L21:
 532               	.LM34:
 533 0238 20E0      		ldi r18,lo8(0x477fff00)
 534 023a 3FEF      		ldi r19,hi8(0x477fff00)
 535 023c 4FE7      		ldi r20,hlo8(0x477fff00)
 536 023e 57E4      		ldi r21,hhi8(0x477fff00)
 537 0240 6D85      		ldd r22,Y+13
 538 0242 7E85      		ldd r23,Y+14
 539 0244 8F85      		ldd r24,Y+15
 540 0246 9889      		ldd r25,Y+16
 541 0248 00D0      		rcall __gtsf2
 542 024a 1816      		cp __zero_reg__,r24
 543 024c 0CF0      		brlt .L25
 544 024e 03C0      		rjmp .L24
 545               	.L25:
 547               	.LM35:
 548 0250 1C86      		std Y+12,__zero_reg__
 549 0252 1B86      		std Y+11,__zero_reg__
 550 0254 09C0      		rjmp .L23
 551               	.L24:
 553               	.LM36:
 554 0256 6D85      		ldd r22,Y+13
 555 0258 7E85      		ldd r23,Y+14
 556 025a 8F85      		ldd r24,Y+15
 557 025c 9889      		ldd r25,Y+16
 558 025e 00D0      		rcall __fixunssfsi
 559 0260 DC01      		movw r26,r24
 560 0262 CB01      		movw r24,r22
 561 0264 9C87      		std Y+12,r25
 562 0266 8B87      		std Y+11,r24
 563               	.L23:
 564               	.LBB8:
 566               	.LM37:
 567 0268 8B85      		ldd r24,Y+11
 568 026a 9C85      		ldd r25,Y+12
 569 026c 9A8B      		std Y+18,r25
 570 026e 898B      		std Y+17,r24
 571               	.LBB9:
 573               	.LM38:
 574 0270 8989      		ldd r24,Y+17
 575 0272 9A89      		ldd r25,Y+18
 576               	/* #APP */
 577 0274 0197      		1: sbiw r24,1
 578 0276 F1F7      		brne 1b
 579               	/* #NOAPP */
 580 0278 9A8B      		std Y+18,r25
 581 027a 898B      		std Y+17,r24
 582               	.LBE9:
 583               	.LBE8:
 584               	.LBE7:
 585               	.LBE6:
 587               	.Ltext4:
  93:ledmeter.c    ****         _delay_ms(delay);
  94:ledmeter.c    ****         switch_off_led(i);
 589               	.LM39:
 590 027c 8D81      		ldd r24,Y+5
 591 027e 9E81      		ldd r25,Y+6
 592 0280 FEDE      		rcall switch_off_led
 594               	.LM40:
 595 0282 8D81      		ldd r24,Y+5
 596 0284 9E81      		ldd r25,Y+6
 597 0286 0197      		sbiw r24,1
 598 0288 9E83      		std Y+6,r25
 599 028a 8D83      		std Y+5,r24
 600 028c A8CF      		rjmp .L18
 601               	.L17:
 602               	/* epilogue: frame size=18 */
 603 028e 6296      		adiw r28,18
 604 0290 0FB6      		in __tmp_reg__,__SREG__
 605 0292 F894      		cli
 606 0294 DEBF      		out __SP_H__,r29
 607 0296 0FBE      		out __SREG__,__tmp_reg__
 608 0298 CDBF      		out __SP_L__,r28
 609 029a DF91      		pop r29
 610 029c CF91      		pop r28
 611 029e 0895      		ret
 612               	/* epilogue end (size=9) */
 613               	/* function switch_off_leds_with_delay size 117 (98) */
 628               	.Lscope5:
 630               	.global	test_leds
 632               	test_leds:
  95:ledmeter.c    ****     }
  96:ledmeter.c    **** }
  97:ledmeter.c    **** 
  98:ledmeter.c    **** /*
  99:ledmeter.c    ****  * a function for testing leds that switch on every leds and switch off every leds (one after one)
 100:ledmeter.c    ****  */
 101:ledmeter.c    **** void test_leds() {
 634               	.LM41:
 635               	/* prologue: frame size=12 */
 636 02a0 CF93      		push r28
 637 02a2 DF93      		push r29
 638 02a4 CDB7      		in r28,__SP_L__
 639 02a6 DEB7      		in r29,__SP_H__
 640 02a8 2C97      		sbiw r28,12
 641 02aa 0FB6      		in __tmp_reg__,__SREG__
 642 02ac F894      		cli
 643 02ae DEBF      		out __SP_H__,r29
 644 02b0 0FBE      		out __SREG__,__tmp_reg__
 645 02b2 CDBF      		out __SP_L__,r28
 646               	/* prologue end (size=10) */
 102:ledmeter.c    ****     switch_on_leds_with_delay(100);
 648               	.LM42:
 649 02b4 60E0      		ldi r22,lo8(0x42c80000)
 650 02b6 70E0      		ldi r23,hi8(0x42c80000)
 651 02b8 88EC      		ldi r24,hlo8(0x42c80000)
 652 02ba 92E4      		ldi r25,hhi8(0x42c80000)
 653 02bc 0ADF      		rcall switch_on_leds_with_delay
 654               	.LBB10:
 656               	.Ltext5:
 658               	.LM43:
 659 02be 80E0      		ldi r24,lo8(0x42480000)
 660 02c0 90E0      		ldi r25,hi8(0x42480000)
 661 02c2 A8E4      		ldi r26,hlo8(0x42480000)
 662 02c4 B2E4      		ldi r27,hhi8(0x42480000)
 663 02c6 8983      		std Y+1,r24
 664 02c8 9A83      		std Y+2,r25
 665 02ca AB83      		std Y+3,r26
 666 02cc BC83      		std Y+4,r27
 667               	.LBB11:
 669               	.LM44:
 670 02ce 20E0      		ldi r18,lo8(0x437a0000)
 671 02d0 30E0      		ldi r19,hi8(0x437a0000)
 672 02d2 4AE7      		ldi r20,hlo8(0x437a0000)
 673 02d4 53E4      		ldi r21,hhi8(0x437a0000)
 674 02d6 6981      		ldd r22,Y+1
 675 02d8 7A81      		ldd r23,Y+2
 676 02da 8B81      		ldd r24,Y+3
 677 02dc 9C81      		ldd r25,Y+4
 678 02de 00D0      		rcall __mulsf3
 679 02e0 DC01      		movw r26,r24
 680 02e2 CB01      		movw r24,r22
 681 02e4 8F83      		std Y+7,r24
 682 02e6 9887      		std Y+8,r25
 683 02e8 A987      		std Y+9,r26
 684 02ea BA87      		std Y+10,r27
 686               	.LM45:
 687 02ec 20E0      		ldi r18,lo8(0x3f800000)
 688 02ee 30E0      		ldi r19,hi8(0x3f800000)
 689 02f0 40E8      		ldi r20,hlo8(0x3f800000)
 690 02f2 5FE3      		ldi r21,hhi8(0x3f800000)
 691 02f4 6F81      		ldd r22,Y+7
 692 02f6 7885      		ldd r23,Y+8
 693 02f8 8985      		ldd r24,Y+9
 694 02fa 9A85      		ldd r25,Y+10
 695 02fc 00D0      		rcall __ltsf2
 696 02fe 8823      		tst r24
 697 0300 0CF0      		brlt .L31
 699               	.LM46:
 700 0302 05C0      		rjmp .L30
 701               	.L31:
 703               	.LM47:
 704 0304 81E0      		ldi r24,lo8(1)
 705 0306 90E0      		ldi r25,hi8(1)
 706 0308 9E83      		std Y+6,r25
 707 030a 8D83      		std Y+5,r24
 708 030c 18C0      		rjmp .L32
 709               	.L30:
 711               	.LM48:
 712 030e 20E0      		ldi r18,lo8(0x477fff00)
 713 0310 3FEF      		ldi r19,hi8(0x477fff00)
 714 0312 4FE7      		ldi r20,hlo8(0x477fff00)
 715 0314 57E4      		ldi r21,hhi8(0x477fff00)
 716 0316 6F81      		ldd r22,Y+7
 717 0318 7885      		ldd r23,Y+8
 718 031a 8985      		ldd r24,Y+9
 719 031c 9A85      		ldd r25,Y+10
 720 031e 00D0      		rcall __gtsf2
 721 0320 1816      		cp __zero_reg__,r24
 722 0322 0CF0      		brlt .L34
 723 0324 03C0      		rjmp .L33
 724               	.L34:
 726               	.LM49:
 727 0326 1E82      		std Y+6,__zero_reg__
 728 0328 1D82      		std Y+5,__zero_reg__
 729 032a 09C0      		rjmp .L32
 730               	.L33:
 732               	.LM50:
 733 032c 6F81      		ldd r22,Y+7
 734 032e 7885      		ldd r23,Y+8
 735 0330 8985      		ldd r24,Y+9
 736 0332 9A85      		ldd r25,Y+10
 737 0334 00D0      		rcall __fixunssfsi
 738 0336 DC01      		movw r26,r24
 739 0338 CB01      		movw r24,r22
 740 033a 9E83      		std Y+6,r25
 741 033c 8D83      		std Y+5,r24
 742               	.L32:
 743               	.LBB12:
 745               	.LM51:
 746 033e 8D81      		ldd r24,Y+5
 747 0340 9E81      		ldd r25,Y+6
 748 0342 9C87      		std Y+12,r25
 749 0344 8B87      		std Y+11,r24
 750               	.LBB13:
 752               	.LM52:
 753 0346 8B85      		ldd r24,Y+11
 754 0348 9C85      		ldd r25,Y+12
 755               	/* #APP */
 756 034a 0197      		1: sbiw r24,1
 757 034c F1F7      		brne 1b
 758               	/* #NOAPP */
 759 034e 9C87      		std Y+12,r25
 760 0350 8B87      		std Y+11,r24
 761               	.LBE13:
 762               	.LBE12:
 763               	.LBE11:
 764               	.LBE10:
 766               	.Ltext6:
 103:ledmeter.c    ****     _delay_ms(50);
 104:ledmeter.c    ****     switch_off_leds_with_delay(100);
 768               	.LM53:
 769 0352 60E0      		ldi r22,lo8(0x42c80000)
 770 0354 70E0      		ldi r23,hi8(0x42c80000)
 771 0356 88EC      		ldi r24,hlo8(0x42c80000)
 772 0358 92E4      		ldi r25,hhi8(0x42c80000)
 773 035a 2FDF      		rcall switch_off_leds_with_delay
 774               	/* epilogue: frame size=12 */
 775 035c 2C96      		adiw r28,12
 776 035e 0FB6      		in __tmp_reg__,__SREG__
 777 0360 F894      		cli
 778 0362 DEBF      		out __SP_H__,r29
 779 0364 0FBE      		out __SREG__,__tmp_reg__
 780 0366 CDBF      		out __SP_L__,r28
 781 0368 DF91      		pop r29
 782 036a CF91      		pop r28
 783 036c 0895      		ret
 784               	/* epilogue end (size=9) */
 785               	/* function test_leds size 105 (86) */
 797               	.Lscope6:
 800               	.global	switch_on_min_dels
 802               	switch_on_min_dels:
 105:ledmeter.c    **** }
 106:ledmeter.c    **** 
 107:ledmeter.c    **** /*
 108:ledmeter.c    ****  *  switch on every leds (from 0 to n)  (and switch off others)
 109:ledmeter.c    ****  */
 110:ledmeter.c    **** void switch_on_min_dels(int n) {
 804               	.LM54:
 805               	/* prologue: frame size=4 */
 806 036e CF93      		push r28
 807 0370 DF93      		push r29
 808 0372 CDB7      		in r28,__SP_L__
 809 0374 DEB7      		in r29,__SP_H__
 810 0376 2497      		sbiw r28,4
 811 0378 0FB6      		in __tmp_reg__,__SREG__
 812 037a F894      		cli
 813 037c DEBF      		out __SP_H__,r29
 814 037e 0FBE      		out __SREG__,__tmp_reg__
 815 0380 CDBF      		out __SP_L__,r28
 816               	/* prologue end (size=10) */
 817 0382 9A83      		std Y+2,r25
 818 0384 8983      		std Y+1,r24
 111:ledmeter.c    ****     int i;
 112:ledmeter.c    ****     for(i = 1; i<=Nleds; i++) {
 820               	.LM55:
 821 0386 81E0      		ldi r24,lo8(1)
 822 0388 90E0      		ldi r25,hi8(1)
 823 038a 9C83      		std Y+4,r25
 824 038c 8B83      		std Y+3,r24
 825               	.L39:
 827               	.LM56:
 828 038e 8B81      		ldd r24,Y+3
 829 0390 9C81      		ldd r25,Y+4
 830 0392 8930      		cpi r24,9
 831 0394 9105      		cpc r25,__zero_reg__
 832 0396 A4F4      		brge .L38
 113:ledmeter.c    ****         if (i<=n) {
 834               	.LM57:
 835 0398 2B81      		ldd r18,Y+3
 836 039a 3C81      		ldd r19,Y+4
 837 039c 8981      		ldd r24,Y+1
 838 039e 9A81      		ldd r25,Y+2
 839 03a0 8217      		cp r24,r18
 840 03a2 9307      		cpc r25,r19
 841 03a4 24F0      		brlt .L42
 114:ledmeter.c    ****             switch_on_led(i);
 843               	.LM58:
 844 03a6 8B81      		ldd r24,Y+3
 845 03a8 9C81      		ldd r25,Y+4
 846 03aa 3DDE      		rcall switch_on_led
 847 03ac 03C0      		rjmp .L41
 848               	.L42:
 115:ledmeter.c    ****         } else {
 116:ledmeter.c    ****             switch_off_led(i);
 850               	.LM59:
 851 03ae 8B81      		ldd r24,Y+3
 852 03b0 9C81      		ldd r25,Y+4
 853 03b2 65DE      		rcall switch_off_led
 854               	.L41:
 856               	.LM60:
 857 03b4 8B81      		ldd r24,Y+3
 858 03b6 9C81      		ldd r25,Y+4
 859 03b8 0196      		adiw r24,1
 860 03ba 9C83      		std Y+4,r25
 861 03bc 8B83      		std Y+3,r24
 862 03be E7CF      		rjmp .L39
 863               	.L38:
 864               	/* epilogue: frame size=4 */
 865 03c0 2496      		adiw r28,4
 866 03c2 0FB6      		in __tmp_reg__,__SREG__
 867 03c4 F894      		cli
 868 03c6 DEBF      		out __SP_H__,r29
 869 03c8 0FBE      		out __SREG__,__tmp_reg__
 870 03ca CDBF      		out __SP_L__,r28
 871 03cc DF91      		pop r29
 872 03ce CF91      		pop r28
 873 03d0 0895      		ret
 874               	/* epilogue end (size=9) */
 875               	/* function switch_on_min_dels size 50 (31) */
 880               	.Lscope7:
 883               	.global	switch_on_max_dels
 885               	switch_on_max_dels:
 117:ledmeter.c    ****         }
 118:ledmeter.c    ****     }
 119:ledmeter.c    **** }
 120:ledmeter.c    **** 
 121:ledmeter.c    **** /*
 122:ledmeter.c    ****  *  switch on every leds (from Nleds to n)
 123:ledmeter.c    ****  */
 124:ledmeter.c    **** void switch_on_max_dels(int n) {
 887               	.LM61:
 888               	/* prologue: frame size=4 */
 889 03d2 CF93      		push r28
 890 03d4 DF93      		push r29
 891 03d6 CDB7      		in r28,__SP_L__
 892 03d8 DEB7      		in r29,__SP_H__
 893 03da 2497      		sbiw r28,4
 894 03dc 0FB6      		in __tmp_reg__,__SREG__
 895 03de F894      		cli
 896 03e0 DEBF      		out __SP_H__,r29
 897 03e2 0FBE      		out __SREG__,__tmp_reg__
 898 03e4 CDBF      		out __SP_L__,r28
 899               	/* prologue end (size=10) */
 900 03e6 9A83      		std Y+2,r25
 901 03e8 8983      		std Y+1,r24
 125:ledmeter.c    ****     int i;
 126:ledmeter.c    ****     for(i = Nleds; i>=0; i--) {
 903               	.LM62:
 904 03ea 88E0      		ldi r24,lo8(8)
 905 03ec 90E0      		ldi r25,hi8(8)
 906 03ee 9C83      		std Y+4,r25
 907 03f0 8B83      		std Y+3,r24
 908               	.L45:
 910               	.LM63:
 911 03f2 8B81      		ldd r24,Y+3
 912 03f4 9C81      		ldd r25,Y+4
 913 03f6 9923      		tst r25
 914 03f8 C4F0      		brlt .L44
 127:ledmeter.c    ****         if (i>=Nleds-n) {
 916               	.LM64:
 917 03fa 28E0      		ldi r18,lo8(8)
 918 03fc 30E0      		ldi r19,hi8(8)
 919 03fe 8981      		ldd r24,Y+1
 920 0400 9A81      		ldd r25,Y+2
 921 0402 281B      		sub r18,r24
 922 0404 390B      		sbc r19,r25
 923 0406 8B81      		ldd r24,Y+3
 924 0408 9C81      		ldd r25,Y+4
 925 040a 8217      		cp r24,r18
 926 040c 9307      		cpc r25,r19
 927 040e 24F0      		brlt .L48
 128:ledmeter.c    ****             switch_on_led(i);
 929               	.LM65:
 930 0410 8B81      		ldd r24,Y+3
 931 0412 9C81      		ldd r25,Y+4
 932 0414 08DE      		rcall switch_on_led
 933 0416 03C0      		rjmp .L47
 934               	.L48:
 129:ledmeter.c    ****         } else {
 130:ledmeter.c    ****             switch_off_led(i);
 936               	.LM66:
 937 0418 8B81      		ldd r24,Y+3
 938 041a 9C81      		ldd r25,Y+4
 939 041c 30DE      		rcall switch_off_led
 940               	.L47:
 942               	.LM67:
 943 041e 8B81      		ldd r24,Y+3
 944 0420 9C81      		ldd r25,Y+4
 945 0422 0197      		sbiw r24,1
 946 0424 9C83      		std Y+4,r25
 947 0426 8B83      		std Y+3,r24
 948 0428 E4CF      		rjmp .L45
 949               	.L44:
 950               	/* epilogue: frame size=4 */
 951 042a 2496      		adiw r28,4
 952 042c 0FB6      		in __tmp_reg__,__SREG__
 953 042e F894      		cli
 954 0430 DEBF      		out __SP_H__,r29
 955 0432 0FBE      		out __SREG__,__tmp_reg__
 956 0434 CDBF      		out __SP_L__,r28
 957 0436 DF91      		pop r29
 958 0438 CF91      		pop r28
 959 043a 0895      		ret
 960               	/* epilogue end (size=9) */
 961               	/* function switch_on_max_dels size 53 (34) */
 966               	.Lscope8:
 969               	.global	led_alarm
 971               	led_alarm:
 131:ledmeter.c    ****         }
 132:ledmeter.c    ****     }
 133:ledmeter.c    ****     // TO TEST (switch off)
 134:ledmeter.c    **** }
 135:ledmeter.c    **** 
 136:ledmeter.c    **** /*
 137:ledmeter.c    ****  * switch off every leds, wait and swith them all, n times (a sort of visual alarm)
 138:ledmeter.c    ****  */
 139:ledmeter.c    **** void led_alarm(int n) {
 973               	.LM68:
 974               	/* prologue: frame size=16 */
 975 043c CF93      		push r28
 976 043e DF93      		push r29
 977 0440 CDB7      		in r28,__SP_L__
 978 0442 DEB7      		in r29,__SP_H__
 979 0444 6097      		sbiw r28,16
 980 0446 0FB6      		in __tmp_reg__,__SREG__
 981 0448 F894      		cli
 982 044a DEBF      		out __SP_H__,r29
 983 044c 0FBE      		out __SREG__,__tmp_reg__
 984 044e CDBF      		out __SP_L__,r28
 985               	/* prologue end (size=10) */
 986 0450 9A83      		std Y+2,r25
 987 0452 8983      		std Y+1,r24
 140:ledmeter.c    ****     int i;
 141:ledmeter.c    ****     for(i = 1; i<=n; i++) {
 989               	.LM69:
 990 0454 81E0      		ldi r24,lo8(1)
 991 0456 90E0      		ldi r25,hi8(1)
 992 0458 9C83      		std Y+4,r25
 993 045a 8B83      		std Y+3,r24
 994               	.L51:
 996               	.LM70:
 997 045c 2B81      		ldd r18,Y+3
 998 045e 3C81      		ldd r19,Y+4
 999 0460 8981      		ldd r24,Y+1
 1000 0462 9A81      		ldd r25,Y+2
 1001 0464 8217      		cp r24,r18
 1002 0466 9307      		cpc r25,r19
 1003 0468 0CF4      		brge .+2
 1004 046a 9CC0      		rjmp .L50
 142:ledmeter.c    ****         switch_off_all_leds();
 1006               	.LM71:
 1007 046c D2DD      		rcall switch_off_all_leds
 1008               	.LBB14:
 1010               	.Ltext7:
 1012               	.LM72:
 1013 046e 80E0      		ldi r24,lo8(0x42480000)
 1014 0470 90E0      		ldi r25,hi8(0x42480000)
 1015 0472 A8E4      		ldi r26,hlo8(0x42480000)
 1016 0474 B2E4      		ldi r27,hhi8(0x42480000)
 1017 0476 8D83      		std Y+5,r24
 1018 0478 9E83      		std Y+6,r25
 1019 047a AF83      		std Y+7,r26
 1020 047c B887      		std Y+8,r27
 1021               	.LBB15:
 1023               	.LM73:
 1024 047e 20E0      		ldi r18,lo8(0x437a0000)
 1025 0480 30E0      		ldi r19,hi8(0x437a0000)
 1026 0482 4AE7      		ldi r20,hlo8(0x437a0000)
 1027 0484 53E4      		ldi r21,hhi8(0x437a0000)
 1028 0486 6D81      		ldd r22,Y+5
 1029 0488 7E81      		ldd r23,Y+6
 1030 048a 8F81      		ldd r24,Y+7
 1031 048c 9885      		ldd r25,Y+8
 1032 048e 00D0      		rcall __mulsf3
 1033 0490 DC01      		movw r26,r24
 1034 0492 CB01      		movw r24,r22
 1035 0494 8B87      		std Y+11,r24
 1036 0496 9C87      		std Y+12,r25
 1037 0498 AD87      		std Y+13,r26
 1038 049a BE87      		std Y+14,r27
 1040               	.LM74:
 1041 049c 20E0      		ldi r18,lo8(0x3f800000)
 1042 049e 30E0      		ldi r19,hi8(0x3f800000)
 1043 04a0 40E8      		ldi r20,hlo8(0x3f800000)
 1044 04a2 5FE3      		ldi r21,hhi8(0x3f800000)
 1045 04a4 6B85      		ldd r22,Y+11
 1046 04a6 7C85      		ldd r23,Y+12
 1047 04a8 8D85      		ldd r24,Y+13
 1048 04aa 9E85      		ldd r25,Y+14
 1049 04ac 00D0      		rcall __ltsf2
 1050 04ae 8823      		tst r24
 1051 04b0 0CF0      		brlt .L55
 1052 04b2 05C0      		rjmp .L54
 1053               	.L55:
 1055               	.LM75:
 1056 04b4 81E0      		ldi r24,lo8(1)
 1057 04b6 90E0      		ldi r25,hi8(1)
 1058 04b8 9A87      		std Y+10,r25
 1059 04ba 8987      		std Y+9,r24
 1060 04bc 18C0      		rjmp .L56
 1061               	.L54:
 1063               	.LM76:
 1064 04be 20E0      		ldi r18,lo8(0x477fff00)
 1065 04c0 3FEF      		ldi r19,hi8(0x477fff00)
 1066 04c2 4FE7      		ldi r20,hlo8(0x477fff00)
 1067 04c4 57E4      		ldi r21,hhi8(0x477fff00)
 1068 04c6 6B85      		ldd r22,Y+11
 1069 04c8 7C85      		ldd r23,Y+12
 1070 04ca 8D85      		ldd r24,Y+13
 1071 04cc 9E85      		ldd r25,Y+14
 1072 04ce 00D0      		rcall __gtsf2
 1073 04d0 1816      		cp __zero_reg__,r24
 1074 04d2 0CF0      		brlt .L58
 1075 04d4 03C0      		rjmp .L57
 1076               	.L58:
 1078               	.LM77:
 1079 04d6 1A86      		std Y+10,__zero_reg__
 1080 04d8 1986      		std Y+9,__zero_reg__
 1081 04da 09C0      		rjmp .L56
 1082               	.L57:
 1084               	.LM78:
 1085 04dc 6B85      		ldd r22,Y+11
 1086 04de 7C85      		ldd r23,Y+12
 1087 04e0 8D85      		ldd r24,Y+13
 1088 04e2 9E85      		ldd r25,Y+14
 1089 04e4 00D0      		rcall __fixunssfsi
 1090 04e6 DC01      		movw r26,r24
 1091 04e8 CB01      		movw r24,r22
 1092 04ea 9A87      		std Y+10,r25
 1093 04ec 8987      		std Y+9,r24
 1094               	.L56:
 1095               	.LBB16:
 1097               	.LM79:
 1098 04ee 8985      		ldd r24,Y+9
 1099 04f0 9A85      		ldd r25,Y+10
 1100 04f2 988B      		std Y+16,r25
 1101 04f4 8F87      		std Y+15,r24
 1102               	.LBB17:
 1104               	.LM80:
 1105 04f6 8F85      		ldd r24,Y+15
 1106 04f8 9889      		ldd r25,Y+16
 1107               	/* #APP */
 1108 04fa 0197      		1: sbiw r24,1
 1109 04fc F1F7      		brne 1b
 1110               	/* #NOAPP */
 1111 04fe 988B      		std Y+16,r25
 1112 0500 8F87      		std Y+15,r24
 1113               	.LBE17:
 1114               	.LBE16:
 1115               	.LBE15:
 1116               	.LBE14:
 1118               	.Ltext8:
 143:ledmeter.c    ****         _delay_ms(50);
 144:ledmeter.c    ****         switch_on_all_leds();
 1120               	.LM81:
 1121 0502 7EDD      		rcall switch_on_all_leds
 1122               	.LBB18:
 1124               	.Ltext9:
 1126               	.LM82:
 1127 0504 80E0      		ldi r24,lo8(0x42480000)
 1128 0506 90E0      		ldi r25,hi8(0x42480000)
 1129 0508 A8E4      		ldi r26,hlo8(0x42480000)
 1130 050a B2E4      		ldi r27,hhi8(0x42480000)
 1131 050c 8B87      		std Y+11,r24
 1132 050e 9C87      		std Y+12,r25
 1133 0510 AD87      		std Y+13,r26
 1134 0512 BE87      		std Y+14,r27
 1135               	.LBB19:
 1137               	.LM83:
 1138 0514 20E0      		ldi r18,lo8(0x437a0000)
 1139 0516 30E0      		ldi r19,hi8(0x437a0000)
 1140 0518 4AE7      		ldi r20,hlo8(0x437a0000)
 1141 051a 53E4      		ldi r21,hhi8(0x437a0000)
 1142 051c 6B85      		ldd r22,Y+11
 1143 051e 7C85      		ldd r23,Y+12
 1144 0520 8D85      		ldd r24,Y+13
 1145 0522 9E85      		ldd r25,Y+14
 1146 0524 00D0      		rcall __mulsf3
 1147 0526 DC01      		movw r26,r24
 1148 0528 CB01      		movw r24,r22
 1149 052a 8D83      		std Y+5,r24
 1150 052c 9E83      		std Y+6,r25
 1151 052e AF83      		std Y+7,r26
 1152 0530 B887      		std Y+8,r27
 1154               	.LM84:
 1155 0532 20E0      		ldi r18,lo8(0x3f800000)
 1156 0534 30E0      		ldi r19,hi8(0x3f800000)
 1157 0536 40E8      		ldi r20,hlo8(0x3f800000)
 1158 0538 5FE3      		ldi r21,hhi8(0x3f800000)
 1159 053a 6D81      		ldd r22,Y+5
 1160 053c 7E81      		ldd r23,Y+6
 1161 053e 8F81      		ldd r24,Y+7
 1162 0540 9885      		ldd r25,Y+8
 1163 0542 00D0      		rcall __ltsf2
 1164 0544 8823      		tst r24
 1165 0546 0CF0      		brlt .L63
 1166 0548 05C0      		rjmp .L62
 1167               	.L63:
 1169               	.LM85:
 1170 054a 81E0      		ldi r24,lo8(1)
 1171 054c 90E0      		ldi r25,hi8(1)
 1172 054e 988B      		std Y+16,r25
 1173 0550 8F87      		std Y+15,r24
 1174 0552 18C0      		rjmp .L64
 1175               	.L62:
 1177               	.LM86:
 1178 0554 20E0      		ldi r18,lo8(0x477fff00)
 1179 0556 3FEF      		ldi r19,hi8(0x477fff00)
 1180 0558 4FE7      		ldi r20,hlo8(0x477fff00)
 1181 055a 57E4      		ldi r21,hhi8(0x477fff00)
 1182 055c 6D81      		ldd r22,Y+5
 1183 055e 7E81      		ldd r23,Y+6
 1184 0560 8F81      		ldd r24,Y+7
 1185 0562 9885      		ldd r25,Y+8
 1186 0564 00D0      		rcall __gtsf2
 1187 0566 1816      		cp __zero_reg__,r24
 1188 0568 0CF0      		brlt .L66
 1189 056a 03C0      		rjmp .L65
 1190               	.L66:
 1192               	.LM87:
 1193 056c 188A      		std Y+16,__zero_reg__
 1194 056e 1F86      		std Y+15,__zero_reg__
 1195 0570 09C0      		rjmp .L64
 1196               	.L65:
 1198               	.LM88:
 1199 0572 6D81      		ldd r22,Y+5
 1200 0574 7E81      		ldd r23,Y+6
 1201 0576 8F81      		ldd r24,Y+7
 1202 0578 9885      		ldd r25,Y+8
 1203 057a 00D0      		rcall __fixunssfsi
 1204 057c DC01      		movw r26,r24
 1205 057e CB01      		movw r24,r22
 1206 0580 988B      		std Y+16,r25
 1207 0582 8F87      		std Y+15,r24
 1208               	.L64:
 1209               	.LBB20:
 1211               	.LM89:
 1212 0584 8F85      		ldd r24,Y+15
 1213 0586 9889      		ldd r25,Y+16
 1214 0588 9A87      		std Y+10,r25
 1215 058a 8987      		std Y+9,r24
 1216               	.LBB21:
 1218               	.LM90:
 1219 058c 8985      		ldd r24,Y+9
 1220 058e 9A85      		ldd r25,Y+10
 1221               	/* #APP */
 1222 0590 0197      		1: sbiw r24,1
 1223 0592 F1F7      		brne 1b
 1224               	/* #NOAPP */
 1225 0594 9A87      		std Y+10,r25
 1226 0596 8987      		std Y+9,r24
 1227               	.LBE21:
 1228               	.LBE20:
 1229               	.LBE19:
 1230               	.LBE18:
 1232               	.Ltext10:
 1234               	.LM91:
 1235 0598 8B81      		ldd r24,Y+3
 1236 059a 9C81      		ldd r25,Y+4
 1237 059c 0196      		adiw r24,1
 1238 059e 9C83      		std Y+4,r25
 1239 05a0 8B83      		std Y+3,r24
 1240 05a2 5CCF      		rjmp .L51
 1241               	.L50:
 1242               	/* epilogue: frame size=16 */
 1243 05a4 6096      		adiw r28,16
 1244 05a6 0FB6      		in __tmp_reg__,__SREG__
 1245 05a8 F894      		cli
 1246 05aa DEBF      		out __SP_H__,r29
 1247 05ac 0FBE      		out __SREG__,__tmp_reg__
 1248 05ae CDBF      		out __SP_L__,r28
 1249 05b0 DF91      		pop r29
 1250 05b2 CF91      		pop r28
 1251 05b4 0895      		ret
 1252               	/* epilogue end (size=9) */
 1253               	/* function led_alarm size 193 (174) */
 1278               	.Lscope9:
 1281               	.global	show_percent
 1283               	show_percent:
 145:ledmeter.c    ****         _delay_ms(50);
 146:ledmeter.c    ****     }
 147:ledmeter.c    **** }
 148:ledmeter.c    **** 
 149:ledmeter.c    **** /*
 150:ledmeter.c    ****  * switch on every dels depending of the percentage p
 151:ledmeter.c    ****  */
 152:ledmeter.c    **** void show_percent(double p) {
 1285               	.LM92:
 1286               	/* prologue: frame size=6 */
 1287 05b6 CF93      		push r28
 1288 05b8 DF93      		push r29
 1289 05ba CDB7      		in r28,__SP_L__
 1290 05bc DEB7      		in r29,__SP_H__
 1291 05be 2697      		sbiw r28,6
 1292 05c0 0FB6      		in __tmp_reg__,__SREG__
 1293 05c2 F894      		cli
 1294 05c4 DEBF      		out __SP_H__,r29
 1295 05c6 0FBE      		out __SREG__,__tmp_reg__
 1296 05c8 CDBF      		out __SP_L__,r28
 1297               	/* prologue end (size=10) */
 1298 05ca 6983      		std Y+1,r22
 1299 05cc 7A83      		std Y+2,r23
 1300 05ce 8B83      		std Y+3,r24
 1301 05d0 9C83      		std Y+4,r25
 153:ledmeter.c    ****     // p pourcent
 154:ledmeter.c    ****     int n;
 155:ledmeter.c    ****     //n = 4;
 156:ledmeter.c    ****     n = floor(p / 100.0 * Nleds); // TO FIX (math.h ceil floor ...)
 1303               	.LM93:
 1304 05d2 20E0      		ldi r18,lo8(0x42c80000)
 1305 05d4 30E0      		ldi r19,hi8(0x42c80000)
 1306 05d6 48EC      		ldi r20,hlo8(0x42c80000)
 1307 05d8 52E4      		ldi r21,hhi8(0x42c80000)
 1308 05da 6981      		ldd r22,Y+1
 1309 05dc 7A81      		ldd r23,Y+2
 1310 05de 8B81      		ldd r24,Y+3
 1311 05e0 9C81      		ldd r25,Y+4
 1312 05e2 00D0      		rcall __divsf3
 1313 05e4 DC01      		movw r26,r24
 1314 05e6 CB01      		movw r24,r22
 1315 05e8 20E0      		ldi r18,lo8(0x41000000)
 1316 05ea 30E0      		ldi r19,hi8(0x41000000)
 1317 05ec 40E0      		ldi r20,hlo8(0x41000000)
 1318 05ee 51E4      		ldi r21,hhi8(0x41000000)
 1319 05f0 BC01      		movw r22,r24
 1320 05f2 CD01      		movw r24,r26
 1321 05f4 00D0      		rcall __mulsf3
 1322 05f6 DC01      		movw r26,r24
 1323 05f8 CB01      		movw r24,r22
 1324 05fa BC01      		movw r22,r24
 1325 05fc CD01      		movw r24,r26
 1326 05fe 00D0      		rcall floor
 1327 0600 DC01      		movw r26,r24
 1328 0602 CB01      		movw r24,r22
 1329 0604 BC01      		movw r22,r24
 1330 0606 CD01      		movw r24,r26
 1331 0608 00D0      		rcall __fixsfsi
 1332 060a DC01      		movw r26,r24
 1333 060c CB01      		movw r24,r22
 1334 060e 9E83      		std Y+6,r25
 1335 0610 8D83      		std Y+5,r24
 157:ledmeter.c    ****     switch_on_min_dels(n);
 1337               	.LM94:
 1338 0612 8D81      		ldd r24,Y+5
 1339 0614 9E81      		ldd r25,Y+6
 1340 0616 ABDE      		rcall switch_on_min_dels
 1341               	/* epilogue: frame size=6 */
 1342 0618 2696      		adiw r28,6
 1343 061a 0FB6      		in __tmp_reg__,__SREG__
 1344 061c F894      		cli
 1345 061e DEBF      		out __SP_H__,r29
 1346 0620 0FBE      		out __SREG__,__tmp_reg__
 1347 0622 CDBF      		out __SP_L__,r28
 1348 0624 DF91      		pop r29
 1349 0626 CF91      		pop r28
 1350 0628 0895      		ret
 1351               	/* epilogue end (size=9) */
 1352               	/* function show_percent size 58 (39) */
 1357               	.Lscope10:
 1359               	.global	StartStopChronometer
 1361               	StartStopChronometer:
 158:ledmeter.c    **** }
 159:ledmeter.c    **** 
 160:ledmeter.c    **** 
 161:ledmeter.c    **** /*
 162:ledmeter.c    ****  * start or stop chronometer
 163:ledmeter.c    ****  */
 164:ledmeter.c    **** void StartStopChronometer() {
 1363               	.LM95:
 1364               	/* prologue: frame size=0 */
 1365 062a CF93      		push r28
 1366 062c DF93      		push r29
 1367 062e CDB7      		in r28,__SP_L__
 1368 0630 DEB7      		in r29,__SP_H__
 1369               	/* prologue end (size=4) */
 165:ledmeter.c    ****     led_alarm(3);
 1371               	.LM96:
 1372 0632 83E0      		ldi r24,lo8(3)
 1373 0634 90E0      		ldi r25,hi8(3)
 1374 0636 02DF      		rcall led_alarm
 1375               	/* epilogue: frame size=0 */
 1376 0638 DF91      		pop r29
 1377 063a CF91      		pop r28
 1378 063c 0895      		ret
 1379               	/* epilogue end (size=3) */
 1380               	/* function StartStopChronometer size 10 (3) */
 1382               	.Lscope11:
 1384               	.global	__vector_1
 1386               	__vector_1:
 166:ledmeter.c    **** }
 167:ledmeter.c    **** 
 168:ledmeter.c    **** /*
 169:ledmeter.c    ****  * interrupt handler example for INT0
 170:ledmeter.c    ****  */
 171:ledmeter.c    **** SIGNAL(SIG_INTERRUPT0) {
 1388               	.LM97:
 1389               	/* prologue: frame size=0 */
 1390 063e 1F92      		push __zero_reg__
 1391 0640 0F92      		push __tmp_reg__
 1392 0642 0FB6      		in __tmp_reg__,__SREG__
 1393 0644 0F92      		push __tmp_reg__
 1394 0646 1124      		clr __zero_reg__
 1395 0648 2F93      		push r18
 1396 064a 3F93      		push r19
 1397 064c 4F93      		push r20
 1398 064e 5F93      		push r21
 1399 0650 6F93      		push r22
 1400 0652 7F93      		push r23
 1401 0654 8F93      		push r24
 1402 0656 9F93      		push r25
 1403 0658 AF93      		push r26
 1404 065a BF93      		push r27
 1405 065c EF93      		push r30
 1406 065e FF93      		push r31
 1407 0660 CF93      		push r28
 1408 0662 DF93      		push r29
 1409 0664 CDB7      		in r28,__SP_L__
 1410 0666 DEB7      		in r29,__SP_H__
 1411               	/* prologue end (size=21) */
 172:ledmeter.c    ****     //StartStopChronometer();
 173:ledmeter.c    ****     StartStopChronometer();
 1413               	.LM98:
 1414 0668 E0DF      		rcall StartStopChronometer
 1415               	/* epilogue: frame size=0 */
 1416 066a DF91      		pop r29
 1417 066c CF91      		pop r28
 1418 066e FF91      		pop r31
 1419 0670 EF91      		pop r30
 1420 0672 BF91      		pop r27
 1421 0674 AF91      		pop r26
 1422 0676 9F91      		pop r25
 1423 0678 8F91      		pop r24
 1424 067a 7F91      		pop r23
 1425 067c 6F91      		pop r22
 1426 067e 5F91      		pop r21
 1427 0680 4F91      		pop r20
 1428 0682 3F91      		pop r19
 1429 0684 2F91      		pop r18
 1430 0686 0F90      		pop __tmp_reg__
 1431 0688 0FBE      		out __SREG__,__tmp_reg__
 1432 068a 0F90      		pop __tmp_reg__
 1433 068c 1F90      		pop __zero_reg__
 1434 068e 1895      		reti
 1435               	/* epilogue end (size=19) */
 1436               	/* function __vector_1 size 41 (1) */
 1438               	.Lscope12:
 1440               	.global	init
 1442               	init:
 174:ledmeter.c    **** }
 175:ledmeter.c    **** 
 176:ledmeter.c    **** 
 177:ledmeter.c    **** 
 178:ledmeter.c    **** /*
 179:ledmeter.c    ****  *  init function
 180:ledmeter.c    ****  */
 181:ledmeter.c    **** void init() {
 1444               	.LM99:
 1445               	/* prologue: frame size=0 */
 1446 0690 CF93      		push r28
 1447 0692 DF93      		push r29
 1448 0694 CDB7      		in r28,__SP_L__
 1449 0696 DEB7      		in r29,__SP_H__
 1450               	/* prologue end (size=4) */
 182:ledmeter.c    ****    // ********
 183:ledmeter.c    ****    // * Dels *
 184:ledmeter.c    ****    // ********
 185:ledmeter.c    ****    DDRC=0xFF; // set up PORTD pins 0 to 7 as output
 1452               	.LM100:
 1453 0698 8FEF      		ldi r24,lo8(-1)
 1454 069a 8093 3400 		sts 52,r24
 186:ledmeter.c    ****    //switch_on_all_leds();
 187:ledmeter.c    ****    switch_off_all_leds();
 1456               	.LM101:
 1457 069e B9DC      		rcall switch_off_all_leds
 188:ledmeter.c    **** 
 189:ledmeter.c    ****    // *********************************
 190:ledmeter.c    ****    // * Start/Stop chronometer (INT0) *
 191:ledmeter.c    ****    // *********************************
 192:ledmeter.c    ****    // Set Pin 6 (PD2) as the pin to use for this example
 193:ledmeter.c    ****    //PCMSK |= (1<<PIND2); // TO FIX
 194:ledmeter.c    ****    //PIND |= (1<<PIND2); // try scls:Error : read-only !!!
 195:ledmeter.c    **** 
 196:ledmeter.c    ****    // interrupt on INT0 pin falling edge (sensor triggered)
 197:ledmeter.c    ****    MCUCR = (1<<ISC01) | (1<<ISC00);
 1459               	.LM102:
 1460 06a0 83E0      		ldi r24,lo8(3)
 1461 06a2 8093 5500 		sts 85,r24
 198:ledmeter.c    **** 
 199:ledmeter.c    ****    // turn on interrupts!
 200:ledmeter.c    ****    //GIMSK  |= (1<<INT0); // TO FIX
 201:ledmeter.c    **** 
 202:ledmeter.c    ****    GICR |= (1<<INT0); //INT0
 1463               	.LM103:
 1464 06a6 8091 5B00 		lds r24,91
 1465 06aa 8064      		ori r24,lo8(64)
 1466 06ac 8093 5B00 		sts 91,r24
 203:ledmeter.c    **** 
 204:ledmeter.c    ****    sei();
 1468               	.LM104:
 1469               	/* #APP */
 1470 06b0 7894      		sei
 205:ledmeter.c    **** 
 206:ledmeter.c    ****    // *************************************************
 207:ledmeter.c    ****    // * Conv Analog to Digital (CAN for RPM and Temp) *
 208:ledmeter.c    ****    // *************************************************
 209:ledmeter.c    **** 
 210:ledmeter.c    **** /*
 211:ledmeter.c    **** 	ADCSRA |= (_BV(ADEN));   // enable ADC (turn on ADC power)
 212:ledmeter.c    **** 	ADCSRA &= ~(_BV(ADATE)); // default to single sample convert mode
 213:ledmeter.c    **** 
 214:ledmeter.c    ****    //  set default prescaler 0x06 -> CPU clk/64      a2dSetPrescaler(0x06)
 215:ledmeter.c    ****    ADCSRA = (((ADCSRA) & ~0x07) | 0x06); // ADC_PRESCALE_MASK 0x07
 216:ledmeter.c    **** 	
 217:ledmeter.c    ****    //	a2dSetReference(0x01);	// set default reference ADC_REFERENCE=0x01  ADC_REFERENCE_MASK=
 218:ledmeter.c    ****    ADMUX = (((ADMUX) & ~0xC0) | (0x01<<6));
 219:ledmeter.c    **** 	
 220:ledmeter.c    **** 	ADMUX &= ~(_BV(ADLAR));  // set to right-adjusted result
 221:ledmeter.c    ****    ADCSRA |= (_BV(ADIE));   // enable ADC interrupts
 222:ledmeter.c    **** 
 223:ledmeter.c    **** 	a2dCompleteFlag = 0;		// clear conversion complete flag (FALSE=0 TRUE=-1)
 224:ledmeter.c    **** 
 225:ledmeter.c    **** 	__asm__ __volatile__ ("sei" ::);
 226:ledmeter.c    **** */
 227:ledmeter.c    **** 	
 228:ledmeter.c    **** 	// configure a2d port (PORTA) as input
 229:ledmeter.c    **** 	// so we can receive analog signals
 230:ledmeter.c    ****    DDRA=0x00;
 1472               	.LM105:
 1473               	/* #NOAPP */
 1474 06b2 1092 3A00 		sts 58,__zero_reg__
 231:ledmeter.c    **** 	// make sure pull-up resistors are turned off
 232:ledmeter.c    **** 	PORTA = 0x00;
 1476               	.LM106:
 1477 06b6 1092 3B00 		sts 59,__zero_reg__
 1478               	/* epilogue: frame size=0 */
 1479 06ba DF91      		pop r29
 1480 06bc CF91      		pop r28
 1481 06be 0895      		ret
 1482               	/* epilogue end (size=3) */
 1483               	/* function init size 25 (18) */
 1485               	.Lscope13:
 1488               	.global	adcConvert10bit
 1490               	adcConvert10bit:
 233:ledmeter.c    **** 
 234:ledmeter.c    ****    // ***************
 235:ledmeter.c    ****    // * Graphic LCD *
 236:ledmeter.c    ****    // ***************
 237:ledmeter.c    **** }
 238:ledmeter.c    **** 
 239:ledmeter.c    **** /*
 240:ledmeter.c    ****  * convert from analog to digital (10 bits)
 241:ledmeter.c    ****  */
 242:ledmeter.c    **** unsigned short adcConvert10bit(unsigned char ch)
 243:ledmeter.c    **** {
 1492               	.LM107:
 1493               	/* prologue: frame size=1 */
 1494 06c0 CF93      		push r28
 1495 06c2 DF93      		push r29
 1496 06c4 CDB7      		in r28,__SP_L__
 1497 06c6 DEB7      		in r29,__SP_H__
 1498 06c8 2197      		sbiw r28,1
 1499 06ca 0FB6      		in __tmp_reg__,__SREG__
 1500 06cc F894      		cli
 1501 06ce DEBF      		out __SP_H__,r29
 1502 06d0 0FBE      		out __SREG__,__tmp_reg__
 1503 06d2 CDBF      		out __SP_L__,r28
 1504               	/* prologue end (size=10) */
 1505 06d4 8983      		std Y+1,r24
 244:ledmeter.c    **** 	a2dCompleteFlag = 0;				// clear conversion complete flag
 1507               	.LM108:
 1508 06d6 1092 0000 		sts a2dCompleteFlag,__zero_reg__
 245:ledmeter.c    **** 	ADMUX = ((ADMUX) & ~0x1F) | (ch & 0x1F);	// set channel ADC_MUX_MASK=0x1F
 1510               	.LM109:
 1511 06da 8091 2700 		lds r24,39
 1512 06de 982F      		mov r25,r24
 1513 06e0 907E      		andi r25,lo8(-32)
 1514 06e2 8981      		ldd r24,Y+1
 1515 06e4 8F71      		andi r24,lo8(31)
 1516 06e6 892B      		or r24,r25
 1517 06e8 8093 2700 		sts 39,r24
 246:ledmeter.c    **** 	ADCSRA |= (_BV(ADIF)); // clear hardware "conversion complete" flag
 1519               	.LM110:
 1520 06ec 8091 2600 		lds r24,38
 1521 06f0 8061      		ori r24,lo8(16)
 1522 06f2 8093 2600 		sts 38,r24
 247:ledmeter.c    **** 	ADCSRA |= (_BV(ADSC)); // start conversion
 1524               	.LM111:
 1525 06f6 8091 2600 		lds r24,38
 1526 06fa 8064      		ori r24,lo8(64)
 1527 06fc 8093 2600 		sts 38,r24
 1528               	.L75:
 248:ledmeter.c    **** 							
 249:ledmeter.c    **** 	//while(!a2dCompleteFlag);				// wait until conversion complete
 250:ledmeter.c    **** 	//while( bit_is_clear(ADCSR, ADIF) );		// wait until conversion complete
 251:ledmeter.c    **** 	while( bit_is_set(ADCSRA, ADSC) );		// wait until conversion complete
 1530               	.LM112:
 1531 0700 8091 2600 		lds r24,38
 1532 0704 9927      		clr r25
 1533 0706 8074      		andi r24,lo8(64)
 1534 0708 9070      		andi r25,hi8(64)
 1535 070a 0097      		sbiw r24,0
 1536 070c 09F0      		breq .L76
 1537 070e F8CF      		rjmp .L75
 1538               	.L76:
 252:ledmeter.c    **** 
 253:ledmeter.c    **** 	// CAUTION: MUST READ ADCL BEFORE ADCH!!!
 254:ledmeter.c    **** 	return ((ADCL) | ((ADCH)<<8));	// read ADC (full 10 bits);
 1540               	.LM113:
 1541 0710 8091 2400 		lds r24,36
 1542 0714 282F      		mov r18,r24
 1543 0716 3327      		clr r19
 1544 0718 8091 2500 		lds r24,37
 1545 071c 9927      		clr r25
 1546 071e 982F      		mov r25,r24
 1547 0720 8827      		clr r24
 1548 0722 282B      		or r18,r24
 1549 0724 392B      		or r19,r25
 1550 0726 C901      		movw r24,r18
 1551               	/* epilogue: frame size=1 */
 1552 0728 2196      		adiw r28,1
 1553 072a 0FB6      		in __tmp_reg__,__SREG__
 1554 072c F894      		cli
 1555 072e DEBF      		out __SP_H__,r29
 1556 0730 0FBE      		out __SREG__,__tmp_reg__
 1557 0732 CDBF      		out __SP_L__,r28
 1558 0734 DF91      		pop r29
 1559 0736 CF91      		pop r28
 1560 0738 0895      		ret
 1561               	/* epilogue end (size=9) */
 1562               	/* function adcConvert10bit size 61 (42) */
 1564               	.Lscope14:
 1567               	.global	adcConvert8bit
 1569               	adcConvert8bit:
 255:ledmeter.c    **** }
 256:ledmeter.c    **** 
 257:ledmeter.c    **** /*
 258:ledmeter.c    ****  * convert from analog to digital (8 bits)
 259:ledmeter.c    ****  * starts conversion, waits until conversion is done, and returns result
 260:ledmeter.c    ****  */
 261:ledmeter.c    **** unsigned char adcConvert8bit(unsigned char ch)
 262:ledmeter.c    **** {
 1571               	.LM114:
 1572               	/* prologue: frame size=1 */
 1573 073a CF93      		push r28
 1574 073c DF93      		push r29
 1575 073e CDB7      		in r28,__SP_L__
 1576 0740 DEB7      		in r29,__SP_H__
 1577 0742 2197      		sbiw r28,1
 1578 0744 0FB6      		in __tmp_reg__,__SREG__
 1579 0746 F894      		cli
 1580 0748 DEBF      		out __SP_H__,r29
 1581 074a 0FBE      		out __SREG__,__tmp_reg__
 1582 074c CDBF      		out __SP_L__,r28
 1583               	/* prologue end (size=10) */
 1584 074e 8983      		std Y+1,r24
 263:ledmeter.c    **** 	// do 10-bit conversion and return highest 8 bits
 264:ledmeter.c    **** 	return adcConvert10bit(ch)>>2;			// return ADC MSB byte
 1586               	.LM115:
 1587 0750 8981      		ldd r24,Y+1
 1588 0752 B6DF      		rcall adcConvert10bit
 1589 0754 9695      		lsr r25
 1590 0756 8795      		ror r24
 1591 0758 9695      		lsr r25
 1592 075a 8795      		ror r24
 1593 075c 9927      		clr r25
 1594               	/* epilogue: frame size=1 */
 1595 075e 2196      		adiw r28,1
 1596 0760 0FB6      		in __tmp_reg__,__SREG__
 1597 0762 F894      		cli
 1598 0764 DEBF      		out __SP_H__,r29
 1599 0766 0FBE      		out __SREG__,__tmp_reg__
 1600 0768 CDBF      		out __SP_L__,r28
 1601 076a DF91      		pop r29
 1602 076c CF91      		pop r28
 1603 076e 0895      		ret
 1604               	/* epilogue end (size=9) */
 1605               	/* function adcConvert8bit size 27 (8) */
 1607               	.Lscope15:
 1609               	.global	loop
 1611               	loop:
 265:ledmeter.c    **** }
 266:ledmeter.c    **** 
 267:ledmeter.c    **** /*
 268:ledmeter.c    ****  *  this is the main loop
 269:ledmeter.c    ****  */
 270:ledmeter.c    **** void loop(void) {
 1613               	.LM116:
 1614               	/* prologue: frame size=14 */
 1615 0770 CF93      		push r28
 1616 0772 DF93      		push r29
 1617 0774 CDB7      		in r28,__SP_L__
 1618 0776 DEB7      		in r29,__SP_H__
 1619 0778 2E97      		sbiw r28,14
 1620 077a 0FB6      		in __tmp_reg__,__SREG__
 1621 077c F894      		cli
 1622 077e DEBF      		out __SP_H__,r29
 1623 0780 0FBE      		out __SREG__,__tmp_reg__
 1624 0782 CDBF      		out __SP_L__,r28
 1625               	/* prologue end (size=10) */
 271:ledmeter.c    ****    //show_percent(0x80 * 100 / 0xFF);
 272:ledmeter.c    **** 
 273:ledmeter.c    ****    int i;
 274:ledmeter.c    ****    for (i = 0; i<=Nleds; i++) {
 1627               	.LM117:
 1628 0784 1A82      		std Y+2,__zero_reg__
 1629 0786 1982      		std Y+1,__zero_reg__
 1630               	.L79:
 1632               	.LM118:
 1633 0788 8981      		ldd r24,Y+1
 1634 078a 9A81      		ldd r25,Y+2
 1635 078c 8930      		cpi r24,9
 1636 078e 9105      		cpc r25,__zero_reg__
 1637 0790 0CF0      		brlt .+2
 1638 0792 53C0      		rjmp .L78
 275:ledmeter.c    ****        //switch_on_max_dels(i);
 276:ledmeter.c    ****        switch_on_min_dels(i);
 1640               	.LM119:
 1641 0794 8981      		ldd r24,Y+1
 1642 0796 9A81      		ldd r25,Y+2
 1643 0798 EADD      		rcall switch_on_min_dels
 1644               	.LBB22:
 1646               	.Ltext11:
 1648               	.LM120:
 1649 079a 80E0      		ldi r24,lo8(0x43fa0000)
 1650 079c 90E0      		ldi r25,hi8(0x43fa0000)
 1651 079e AAEF      		ldi r26,hlo8(0x43fa0000)
 1652 07a0 B3E4      		ldi r27,hhi8(0x43fa0000)
 1653 07a2 8B83      		std Y+3,r24
 1654 07a4 9C83      		std Y+4,r25
 1655 07a6 AD83      		std Y+5,r26
 1656 07a8 BE83      		std Y+6,r27
 1657               	.LBB23:
 1659               	.LM121:
 1660 07aa 20E0      		ldi r18,lo8(0x437a0000)
 1661 07ac 30E0      		ldi r19,hi8(0x437a0000)
 1662 07ae 4AE7      		ldi r20,hlo8(0x437a0000)
 1663 07b0 53E4      		ldi r21,hhi8(0x437a0000)
 1664 07b2 6B81      		ldd r22,Y+3
 1665 07b4 7C81      		ldd r23,Y+4
 1666 07b6 8D81      		ldd r24,Y+5
 1667 07b8 9E81      		ldd r25,Y+6
 1668 07ba 00D0      		rcall __mulsf3
 1669 07bc DC01      		movw r26,r24
 1670 07be CB01      		movw r24,r22
 1671 07c0 8987      		std Y+9,r24
 1672 07c2 9A87      		std Y+10,r25
 1673 07c4 AB87      		std Y+11,r26
 1674 07c6 BC87      		std Y+12,r27
 1676               	.LM122:
 1677 07c8 20E0      		ldi r18,lo8(0x3f800000)
 1678 07ca 30E0      		ldi r19,hi8(0x3f800000)
 1679 07cc 40E8      		ldi r20,hlo8(0x3f800000)
 1680 07ce 5FE3      		ldi r21,hhi8(0x3f800000)
 1681 07d0 6985      		ldd r22,Y+9
 1682 07d2 7A85      		ldd r23,Y+10
 1683 07d4 8B85      		ldd r24,Y+11
 1684 07d6 9C85      		ldd r25,Y+12
 1685 07d8 00D0      		rcall __ltsf2
 1686 07da 8823      		tst r24
 1687 07dc 0CF0      		brlt .L83
 1688 07de 05C0      		rjmp .L82
 1689               	.L83:
 1691               	.LM123:
 1692 07e0 81E0      		ldi r24,lo8(1)
 1693 07e2 90E0      		ldi r25,hi8(1)
 1694 07e4 9887      		std Y+8,r25
 1695 07e6 8F83      		std Y+7,r24
 1696 07e8 18C0      		rjmp .L84
 1697               	.L82:
 1699               	.LM124:
 1700 07ea 20E0      		ldi r18,lo8(0x477fff00)
 1701 07ec 3FEF      		ldi r19,hi8(0x477fff00)
 1702 07ee 4FE7      		ldi r20,hlo8(0x477fff00)
 1703 07f0 57E4      		ldi r21,hhi8(0x477fff00)
 1704 07f2 6985      		ldd r22,Y+9
 1705 07f4 7A85      		ldd r23,Y+10
 1706 07f6 8B85      		ldd r24,Y+11
 1707 07f8 9C85      		ldd r25,Y+12
 1708 07fa 00D0      		rcall __gtsf2
 1709 07fc 1816      		cp __zero_reg__,r24
 1710 07fe 0CF0      		brlt .L86
 1711 0800 03C0      		rjmp .L85
 1712               	.L86:
 1714               	.LM125:
 1715 0802 1886      		std Y+8,__zero_reg__
 1716 0804 1F82      		std Y+7,__zero_reg__
 1717 0806 09C0      		rjmp .L84
 1718               	.L85:
 1720               	.LM126:
 1721 0808 6985      		ldd r22,Y+9
 1722 080a 7A85      		ldd r23,Y+10
 1723 080c 8B85      		ldd r24,Y+11
 1724 080e 9C85      		ldd r25,Y+12
 1725 0810 00D0      		rcall __fixunssfsi
 1726 0812 DC01      		movw r26,r24
 1727 0814 CB01      		movw r24,r22
 1728 0816 9887      		std Y+8,r25
 1729 0818 8F83      		std Y+7,r24
 1730               	.L84:
 1731               	.LBB24:
 1733               	.LM127:
 1734 081a 8F81      		ldd r24,Y+7
 1735 081c 9885      		ldd r25,Y+8
 1736 081e 9E87      		std Y+14,r25
 1737 0820 8D87      		std Y+13,r24
 1738               	.LBB25:
 1740               	.LM128:
 1741 0822 8D85      		ldd r24,Y+13
 1742 0824 9E85      		ldd r25,Y+14
 1743               	/* #APP */
 1744 0826 0197      		1: sbiw r24,1
 1745 0828 F1F7      		brne 1b
 1746               	/* #NOAPP */
 1747 082a 9E87      		std Y+14,r25
 1748 082c 8D87      		std Y+13,r24
 1749               	.LBE25:
 1750               	.LBE24:
 1751               	.LBE23:
 1752               	.LBE22:
 1754               	.Ltext12:
 1756               	.LM129:
 1757 082e 8981      		ldd r24,Y+1
 1758 0830 9A81      		ldd r25,Y+2
 1759 0832 0196      		adiw r24,1
 1760 0834 9A83      		std Y+2,r25
 1761 0836 8983      		std Y+1,r24
 1762 0838 A7CF      		rjmp .L79
 1763               	.L78:
 1764               	/* epilogue: frame size=14 */
 1765 083a 2E96      		adiw r28,14
 1766 083c 0FB6      		in __tmp_reg__,__SREG__
 1767 083e F894      		cli
 1768 0840 DEBF      		out __SP_H__,r29
 1769 0842 0FBE      		out __SREG__,__tmp_reg__
 1770 0844 CDBF      		out __SP_L__,r28
 1771 0846 DF91      		pop r29
 1772 0848 CF91      		pop r28
 1773 084a 0895      		ret
 1774               	/* epilogue end (size=9) */
 1775               	/* function loop size 112 (93) */
 1790               	.Lscope16:
 1792               	.global	main
 1794               	main:
 277:ledmeter.c    ****        _delay_ms(500);
 278:ledmeter.c    ****    }
 279:ledmeter.c    **** 
 280:ledmeter.c    ****    //show_percent(adcConvert10bit(0));
 281:ledmeter.c    **** 
 282:ledmeter.c    ****    /*
 283:ledmeter.c    ****    show_percent(25);
 284:ledmeter.c    ****    _delay_ms(500);
 285:ledmeter.c    ****    show_percent(50);
 286:ledmeter.c    ****    _delay_ms(500);
 287:ledmeter.c    ****    show_percent(100);
 288:ledmeter.c    ****    _delay_ms(500);
 289:ledmeter.c    ****    show_percent(75);
 290:ledmeter.c    ****    _delay_ms(500);
 291:ledmeter.c    ****    show_percent(50);
 292:ledmeter.c    ****    */
 293:ledmeter.c    **** 
 294:ledmeter.c    ****    //led_alarm(3);
 295:ledmeter.c    **** 
 296:ledmeter.c    ****    //test_leds();
 297:ledmeter.c    ****    //switch_on_min_dels(5);
 298:ledmeter.c    ****    //switch_on_max_dels(3);
 299:ledmeter.c    **** 
 300:ledmeter.c    **** 	//switch_on_led(3);
 301:ledmeter.c    **** 	//switch_on_led(5);
 302:ledmeter.c    **** 	//switch_on_led(7);
 303:ledmeter.c    **** 	//switch_on_led(8);	
 304:ledmeter.c    **** 	
 305:ledmeter.c    **** 	//switch_off_led(5);
 306:ledmeter.c    **** }
 307:ledmeter.c    **** 
 308:ledmeter.c    **** 
 309:ledmeter.c    **** /*
 310:ledmeter.c    ****  * main program
 311:ledmeter.c    ****  */
 312:ledmeter.c    **** int main(void) {
 1796               	.LM130:
 1797               	/* prologue: frame size=0 */
 1798 084c C0E0      		ldi r28,lo8(__stack - 0)
 1799 084e D0E0      		ldi r29,hi8(__stack - 0)
 1800 0850 DEBF      		out __SP_H__,r29
 1801 0852 CDBF      		out __SP_L__,r28
 1802               	/* prologue end (size=4) */
 313:ledmeter.c    ****    init();
 1804               	.LM131:
 1805 0854 1DDF      		rcall init
 1806               	.L91:
 314:ledmeter.c    **** 
 315:ledmeter.c    ****    while(1) { // Infinite loop; define here the
 316:ledmeter.c    ****       loop(); // system behaviour
 1808               	.LM132:
 1809 0856 8CDF      		rcall loop
 1810 0858 FECF      		rjmp .L91
 1811               	/* epilogue: frame size=0 */
 1812               	/* epilogue: noreturn */
 1813               	/* epilogue end (size=0) */
 1814               	/* function main size 7 (3) */
 1816               	.Lscope17:
 1817               		.comm a2dCompleteFlag,1,1
 1819               		.text
 1821               	Letext:
 1822               	/* File "ledmeter.c": code 1082 = 0x043a ( 782), prologues 161, epilogues 139 */
DEFINED SYMBOLS
                            *ABS*:00000000 ledmeter.c
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:3      *ABS*:0000003f __SREG__
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:4      *ABS*:0000003e __SP_H__
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:5      *ABS*:0000003d __SP_L__
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:6      *ABS*:00000000 __tmp_reg__
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:7      *ABS*:00000001 __zero_reg__
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:76     .text:00000000 switch_on_all_leds
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:99     .text:00000012 switch_off_all_leds
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:124    .text:00000026 switch_on_led
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:190    .text:0000007e switch_off_led
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:254    .text:000000d2 switch_on_leds_with_delay
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:444    .text:000001ba switch_off_leds_with_delay
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:632    .text:000002a0 test_leds
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:802    .text:0000036e switch_on_min_dels
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:885    .text:000003d2 switch_on_max_dels
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:971    .text:0000043c led_alarm
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:1283   .text:000005b6 show_percent
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:1361   .text:0000062a StartStopChronometer
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:1386   .text:0000063e __vector_1
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:1442   .text:00000690 init
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:1490   .text:000006c0 adcConvert10bit
                            *COM*:00000001 a2dCompleteFlag
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:1569   .text:0000073a adcConvert8bit
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:1611   .text:00000770 loop
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:1794   .text:0000084c main
C:\DOCUME~1\scls\LOCALS~1\Temp/cceQaaaa.s:1821   .text:0000085a Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__mulsf3
__ltsf2
__gtsf2
__fixunssfsi
__divsf3
floor
__fixsfsi
__stack
